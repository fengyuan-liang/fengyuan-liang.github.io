# Spring Transaction（事物）学习一、数据库事物、隔离级别

>记录一下对`Spring`和`数据库事物`的学习，这里的Spring事物学习使用的是`全注解`的形式，再此之前需要先学习一下数据库的

## 1、数据库事物

思维导图：

![image-20220225190617969](https://cdn.fengxianhub.top/resources-master/202202251906200.png)



### 1.1 事物的四个特点

>事务的定义很严格，它必须同时满足四个特性，即`原子性`、`一致性`、`隔离性`和`持久性`，也就是人们俗称的 ACID 特性，具体如下：

- 原子性（Atomic）

  表示将事务中所进行的操作捆绑成一个不可分割的单元，即对事务所进行的数据修改等操作，要么全部执行，要么全都不执行

  **数据库是如何保证事物的原子性的？**通过三个`关键字`

  ```java
  commit提交
  rollback回滚
  savepoint保存点
  ```

  **Java是如何保证事物的原子性的？**通过三个`方法`

  ```java
  connection.setAutoCommit(false)//关闭自动事物提交，因为JDBC中隐式事物提交的，即默认提交
  connection.commit()//手动提交事物
  connetion.rollback()//回滚
  ```

- 一致性（Consistency）

  表示事务完成时，必须使所有的数据都保持一致状态。比如转账，有人转出就必须要保证有人转入

- 隔离性（Isolation）

  指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

  **多个线程访问数据库中如何保证数据库中数据的可见性？**

  Java多线程下有可见性问题，操作系统多核开发时也有可见性问题，数据库里这样的问题用`隔离性`描述，其实道理都是相通的，每个线程访问数据库时，都有一份复制的临时数据，数据库对此设置了`四种事物的隔离级别`，分别是：`Read Uncommitted（读未提交）`、`Read Committed（读已提交）`、`Repeatable Read（可重复读取）`、`Serializable（可串行化）`。在下面会专门来描述一下。

- 持久性（Durability）

  持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。提交后的其他操作或故障不会对其有任何影响。

<hr>

### 1.2 数据库并发带来的问题

>在实际应用中，数据库中的数据是要被多个用户共同访问的，在多个用户同时操作相同的数据时，可能就会出现一些事务的并发问题，具体如下

- 脏读

  指一个事务读取到另一个事务未提交的数据。例如`t2`读了数据库中的一条数据，修改后并没有提交，这时`t1`线程去读同一条数据，但是读到是未刷新的数据，即读到了`脏数据`

  ![image-20220128133049942](https://cdn.fengxianhub.top/resources-master/202201281330003.png)

![image-20220128132046122](https://cdn.fengxianhub.top/resources-master/202201281320185.png)

- 不可重复读

  指一个事务对同一行数据重复读取两次，但得到的结果不同。例如A线程两次读取同一条数据，但是在第二次读取前，其他线程对其进行了修改，这就导致A线程两次读取数据的不一致。这里其他线程的操作是`update`更新

- 虚读/幻读

  指一个事务执行两次查询，`但第二次查询的结果包含了第一次查询中未出现的数据`。这里其他线程的操作是`insert`插入

- 丢失更新

  指两个事务同时更新一行数据，后提交（或撤销）的事务将之前事务提交的数据覆盖了

  丢失更新可分为两类，分别是`第一类丢失更新`和`第二类丢失更新`。

  - 第一类丢失更新是指两个事务同时操作同一个数据时，当第一个事务`撤销`时，把已经提交的第二个事务的更新数据覆盖了，第二个事务就造成了数据丢失。
  - 第二类丢失更新是指当两个事务同时操作同一个数据时，第一个事务将修改结果成功`提交`后，对第二个事务已经提交的修改结果进行了覆盖，对第二个事务造成了数据丢失。

### 1.3 数据库的四种隔离级别

>为了避免上述事务并发问题的出现，在标准的 SQL 规范中定义了`四种事务隔离级别`，不同的隔离级别对事务的处理有所不同。这四种事务的隔离级别如下(其安全性由低到高、效率由高到低):

#### Read Uncommitted（读未提交）

一个事务在执行过程中，既可以访问其他事务未提交的新插入的数据，又可以访问未提交的修改数据。如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据。`此隔离级别可防止丢失更新，不能防止其他三种异常`

#### Read Committed（读已提交）

一个事务在执行过程中，既可以访问其他事务成功提交的新插入的数据，又可以访问成功修改的数据。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。`此隔离级别可有效防止脏读`

#### Repeatable Read（可重复读取）

一个事务在执行过程中，可以访问其他事务成功提交的新插入的数据，但不可以访问成功修改的数据。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。`此隔离级别可有效防止不可重复读和脏读`

#### Serializable（可串行化）

提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。`此隔离级别可有效防止脏读、不可重复读和幻读`。但这个级别可能导致大量的超时现象和锁竞争，在实际应用中很少使用

>Serializable 是一致性最好的，性能最差的，Read uncommitted是一致性（隔离性）最差的，性能最好的。一般不会使用` Serializable` 和`Read uncommitted` 这两种隔离级别。一般来说，事务的隔离级别越高，越能保证数据库的完整性和一致性，但相对来说，隔离级别越高，对并发性能的影响也越大。因此，通常将数据库的隔离级别设置为 `Read Committed`，即读已提交数据，它既能防止脏读，又能有较好的并发性能。虽然这种隔离级别会导致不可重复读、幻读和第二类丢失更新这些并发问题，但可通过在应用程序中采用悲观锁和乐观锁加以控制

### 1.4 常用数据库的默认隔离级别

- oracle、sqlServer 读已提交（READ COMMITTED ）
- mysql 可重复读（REPEATABLE-READ）

mysql 可以通过下面的语句来查询数据库的默认隔离级别（查询了全局事物隔离级别和会话事物隔离级别）：

```sql
 select @@global.transaction_isolation,@@transaction_isolation;
```

![image-20220225200822652](https://cdn.fengxianhub.top/resources-master/202202252008734.png)

当然也可以手动修改数据库的事物隔离级别

### 1.5事物处理的两种情况

- 不同数据库（跨数据源）之间统一事物管理，使用`JTA`处理
- 相同数据库（但数据源）管理事物，使用`JDBC`











