# Mysql调优经验

## 1. 索引

>覆盖索引、回表、下推、最左、explain分析执行计划

首先创建索引会考虑一下几个因素：

### 1.1 覆盖索引

`覆盖索引`可以有效减少**回表次数**，其中Mysql5.6之后对`覆盖索引`做了优化，可以支持**索引下推**的一个功能

我们可以把覆盖索引所覆盖的字段进一步进行筛选，尽可能的减少回表次数

此项可以在`explain`中查看执行计划的时候，通过`Extra`字段里面的`Using index Condition`查看到

如果我们的存储介质采用的是机械硬盘，因为机械硬盘不能进行随机读写，有磁盘寻址的开销

这时我们可以把`Mrr`打开，也就是`Multi range read`，它可以在回表之前把我们的ID读到一个`Buffer`里面，并进行一个排序，把原本的随机操作变成一个顺序操作

以上就是覆盖索引做的一些优化，覆盖索引可以避免，例如排序用到的一些临时文件

可以通过最左原则和覆盖索引配合减少一些索引的维护

### 1.2 使用普通索引

针对写多读少且对唯一性要求不高服务（可以通过业务代码保证索引的唯一性），这时我们可以使用普通索引，因为普通索引可以使用`Change Buffer`，`Change Buffer`可以将一些写操作缓存下来，在我们读的时候进行`Merge`操作，这样就可以提高我们写入的速度和内存的命中率

### 1.3 索引未命中的情况

如果我们的索引未命中，首先我们应该看是不是sql写的有问题，例如：

- 我们对索引字段进行了一些函数操作
- 连接表查询的时候，两个表的编码集不一样

如果还是索引未命中，我们可以再进一步排查，有没有可能连接表查询时两个字段的类型不一样，例如说String，赋值给ID时，如果String要跟ID进行比较，在Mysql中会把String自动转成ID，通过隐式函数`cast`进行转换

如果sql并没有问题，可以考虑是不是`索引统计`有问题

如果`索引统计`统计有问题，我们可以去`Analyze table`重新统计所有的信息，因为我们知道索引信息并不是一个准确值，而是一个随机采样的过程，可能会出现问题

此外也有可能是我们的业务表过多，造成内存空洞较多，都可能造成索引选择的问题

### 1.4 explain分析出来的索引一定是最优的吗？

是不一定的，可能会选错，因为我们在索引的时候，可能会设计到一些回表操作和一些排序操作

### 1.5 索引原因导致慢查询

索引建的不好，索引走的很差，出现查询速度很慢的情况

碰到这种情况，我们首先考虑使用`force index`，强制走索引，但是这样是不太好的，应该作为业务的一个应急预案

因为这种方式如果迁移数据库会导致不支持的情况，并且这种方式还需要做一个代码的重新发布，这种是不太好的

我们其实首先应该考虑的是能不能通过最左原则和覆盖索引把选错的索引删除