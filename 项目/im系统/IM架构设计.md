# IM架构设计

1.

## 2. IO模型设计

在设计IM系统之前，我们需要先了解`IO`模型







## 3. 粘包与半包

### 3.1 现象分析

粘包

* 现象，发送 abc def，接收 abcdef
* 原因
  * 应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）
  * 滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包
  * Nagle 算法：会造成粘包

半包

* 现象，发送 abcdef，接收 abc def
* 原因
  * 应用层：接收方 ByteBuf 小于实际发送数据量
  * 滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包
  * MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包

**本质是因为 TCP 是流式协议，消息无边界**



> 滑动窗口
>
> * TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差
>
>   ![](https://cdn.fengxianhub.top/resources-master/202303082115222.png)
>
> 
>
> * 为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值
>
>   ![](https://cdn.fengxianhub.top/resources-master/202303082115305.png)
>
> * 窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用
>
>   * 图中深色的部分即要发送的数据，高亮的部分即窗口
>   * 窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动
>   * 如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动
>   * 接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收



>  MSS 限制
>
>  * 链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如
>
>   * 以太网的 MTU 是 1500
>   * FDDI（光纤分布式数据接口）的 MTU 是 4352
>   * 本地回环地址的 MTU 是 65535 - 本地测试不走网卡
>
>  * MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数
>
>   * ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460
>   * TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送
>   * MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS
>
>   <img src="https://cdn.fengxianhub.top/resources-master/202303082116918.jpg" style="zoom:50%;" />



> Nagle 算法
>
> * 即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由
> * 该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送
>   * 如果 SO_SNDBUF 的数据达到 MSS，则需要发送
>   * 如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭
>   * 如果 TCP_NODELAY = true，则需要发送
>   * 已发送的数据都收到 ack 时，则需要发送
>   * 上述条件不满足，但发生超时（一般为 200ms）则需要发送
>   * 除上述情况，延迟发送

### 3.2 解决方案

1. 短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低
2. 每一条消息采用固定长度，缺点浪费空间
3. 每一条消息采用分隔符，例如 `\n`，缺点需要转义
4. 每一条消息分为 head 和 body，head 中包含 body 的长度（TLV格式，一般协议例如http都使用此实现）

![image-20230308211825322](https://cdn.fengxianhub.top/resources-master/202303082118383.png)

### 3.3 TLV格式解决

首先我们研究一下`netty`中如何解决的

netty源码地址

```java
io.netty.handler.codec.LengthFieldBasedFrameDecoder
```

![image-20230305192148805](https://cdn.fengxianhub.top/resources-master/202303051921070.png)

- lengthFieldOffset：长度字段偏移量
- lengthFieldLength：长度字段长度
- lengthAdjustment：长度字段为基准，还有几个字节为内容
- initialBytesToStrip：从头剥离几个字节

我们看netty注解里面给的一个栗子，其中`lengthFieldLength`为2表示用两个字节来记录长度

>如果我们想在长度解析完之后将`lengthFieldLength`去掉，那么我们可以用`initialBytesToStrip`记录，表示要剥离前多少个字节的长度

![image-20230305192831494](https://cdn.fengxianhub.top/resources-master/202303051928634.png)

>有的时候我们需要在消息之前多发一些东西，例如下面的`魔术字`，所以我们可以`lengthFieldOffset`表示长度要从多少个字节后开始读，用`lengthFieldLength`表示记录长度占用的字节数

![image-20230305193009257](https://cdn.fengxianhub.top/resources-master/202303051930395.png)

>下面的例子中，`lengthAdjustment`为2，表示要从`length`字段后跳过多少个（2个）才是真正的数据

![image-20230305193327729](https://cdn.fengxianhub.top/resources-master/202303051933871.png)

>下面的例子中使用了四个参数来记录消息

![image-20230305193609023](https://cdn.fengxianhub.top/resources-master/202303051936198.png)

在发送消息前，先约定用定长字节表示接下来数据的长度

```java
// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数
ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 1, 0, 1));
```

## 4. 协议设计与解析

### 4.1 为什么需要协议？

TCP/IP 中消息传输基于流的方式，没有边界。

协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则

例如：在网络上传输

```
下雨天留客天留我不留
```

是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性

一种解读

```
下雨天留客，天留，我不留
```

另一种解读

```
下雨天，留客天，留我不？留
```

如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用

``` 
定长字节表示内容长度 + 实际内容
```

例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了

```
0f下雨天留客06天留09我不留
```

### 4.2 自定义协议要素

* 魔数，用来在第一时间判定是否是无效数据包（java class文件魔术为`ca fe ba be`）
* 版本号，可以支持协议的升级
* 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk（不能跨平台、效率低）
* 指令类型，是登录、注册、单聊、群聊... 跟业务相关
* 请求序号，为了双工通信，提供异步能力
* 正文长度
* 消息正文

### 4.3 编解码器实现

















## 附录一 IM基础概念

### 用户（User）

- 用户，就是使用IM 系统的一个人的代表。是通讯的一方。
- 在业务系统，对接IM 平台时，对需要登录IM 系统的用户，必须对应创建一个IM 用户。

用户的主要属性有：

- user_id：唯一标识一个用户
- user_number：用户的外显ID，给用户展示使用，有靓号控制和排除不合理ID等需求
- username：用户昵称，需要支持特殊编码格式的字符，例如emoji字符
- password：密码
- 昵称：在会话，好友，消息等展示时，用于文本显示。
- 头像：在会话，好友，消息等展示时，用于图片显示。
- 其他属性

### 群（Group）

- 群，是一个允许多人聊天的一个关系。
- 用户在群里发送消息，所有群成员都能够收到。

群的主要属性有：

- group_id：群的唯一标识
- 名称：在会话，群展示时，用于文本显示。
- 头像：在会话，群展示时，用于图片显示。
- owner：群主。一个群只有一个群主，一般是群的创建者，有的可以转移。群的最高权限管理员。
- admin：管理员。一个群可以有多个管理员。管理员可以做一些群的管理功能。比如：接收进群申请，禁言用户等。不同的系统有不同的权限定义。
- member：普通群成员。一个群有多个普通群成员。
- 其他属性

### 聊天室(ChatRoom)

聊天室，是一个特殊的群，与普通群的差别一般有：

- 群成员在离线一段时间后，会主动退出聊天室。（个人认为，是核心区别）。
- 离线消息的数量，会比普通群少。
- 历史消息的数量与时间：会比普通群偏短，偏少。

### 好友(Friend)

- 有的又称联系人。
- 好友是两个用户之间的关系。
- 一般在普通聊天类的应用，需要成为还有关系，才能互相发送消息。

好友的一般属性（普通用户属性之外）：

- 备注
- 分组
- 等

### 会话(Conversation)

会话可以看做是一个临时的关系。

- 用户会话：用户与用户之间的会话。
- 群会话：用户与群/聊天室之间的会话。
- 会话是分方向的：用户A与用户B形成的会话，实际是两个会话。一个是用户A的会话，目标是用户B；另一个是用户B的会话，目标是用户A。两者对会话的操作互不影响。

会话一般的属性有（除了群，或者用户信息外）：

- 最后一条消息：
- 未读消息数：
- 免打扰（不显示未读计数，不推送）
- 置顶
- 等

### 消息(Message)

消息是一个用户，与另一个用户/群的通信内容的载体。

消息的主要属性：

- from：发送用户（user_id)
- to：接收者（用户，群）
- 消息类型：文本，图片，语音，视频等
- 消息内容：对于图片，语音，视频，文件等大多以文件的url 来代替。
- 时间：
- 状态：发送方(发送中，发送成功，发送失败)，接收方（已读，未读）。

### 未读消息/未读计数

- 用户收到消息，未查看的消息。
- 在会话上/角标处会显示未读计数，标识当前未读消息的计数。
- 在用户点进去一个会话，会将该会话的未读计数清零。

## 附录二 IM基础功能

### 好友

好友

- 好友申请
- 拒绝申请
- 同意申请
- 删除好友

黑名单

- 添加黑名单
- 删除黑名单

### 群

- 申请进群（如果设置了需要申请，否则可以直接进群）
- 同意进群申请
- 拒绝进群申请
- 退出群
- 修改群信息：名称，头像，公告等。
- 邀请进群
- 踢出用户（需要管理员）
- 禁言/取消禁言

### 消息

- 发送消息
- 删除消息：删除本地消息，只对自己（单设备）有效。其他人，甚至自己的其他设备如果已经接收了该消息，都还能看到这个消息。
- 撤回消息：只有消息发送者，或者群管理员可以撤回消息。撤回消息后，其他用户都看不到这个消息。一般有时间限制。

### 会话

#### 会话创建

- 发消息，自动创建会话

#### 会话删除

- 会话删除一般是客户端本端的行为。
- 会话删除，可以视为会话本身的一个软删除，不会删除对应的好友，群。
- 会话删除，不影响会话中的消息。（微信应该是删除本地消息）。

### 离线消息/历史消息

#### 离线消息

- 当接收消息的用户不在线时，消息会进入离线消息缓存。
- 当用户上线，会同步离线消息到本地。
- 离线消息有存储时间限制
- 离线消息有存储数量限制

#### 历史消息

- 用户接收消息后，消息并不会立即从服务端删除。还会在服务端继续保存一段时间，称为历史消息。
- 一般可以按会话获取历史消息。

### 推送

- 推送，实际上不是IM。是一套独立的系统。
- IM 会使用推送，来提高消息的及时触达性

