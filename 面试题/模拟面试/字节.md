# 字节

## 第一次模拟面试2022年6月25日08:39:37

### 简述一下 GDB 常见的调试命令

>（gdb）help：查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h
>（gdb）run：重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r
>（gdb）start：单步执行，运行程序，停在第一执行语句
>（gdb）list：查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l
>（gdb）set：设置变量的值
>（gdb）next：单步调试（逐过程，函数直接执行）,简写n
>（gdb）step：单步调试（逐语句：跳入自定义函数内部执行）,简写s
>（gdb）backtrace：查看函数的调用的栈帧和层级关系,简写bt
>（gdb）frame：切换函数的栈帧,简写f
>（gdb）info：查看函数内部局部变量的数值,简写i
>（gdb）finish：结束当前函数，返回到函数调用点
>（gdb）continue：继续运行,简写c
>（gdb）print：打印值及地址,简写p
>（gdb）quit：退出gdb,简写q
>（gdb）break+num：在第num行设置断点,简写b
>（gdb）info breakpoints：查看当前设置的所有断点
>（gdb）delete breakpoints num：删除第num个断点,简写d
>（gdb）display：追踪查看具体变量值
>（gdb）undisplay：取消追踪观察变量
>（gdb）watch：被设置观察点的变量发生修改时，打印显示
>（gdb）i watch：显示观察点
>（gdb）enable breakpoints：启用断点
>（gdb）disable breakpoints：禁用断点
>（gdb）x：查看内存x/20xw 显示20个单元，16进制，4字节每单元
>（gdb）run argv[1] argv[2]：调试时命令行传参
>（gdb）set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork()）

### 说一说线程同步的方式

1. 互斥锁 2. 读写锁 3. 条件变量 4. 信号量 5. 自旋锁 6. 屏障（barrier）

>#### 参考回答
>
>
>
>【得分点】
>
>  synchronized、Lock
>
>【参考答案】
>
>标准回答
>
>  Java主要通过加锁的方式实现线程同步，而锁有两类，分别是synchronized和Lock。
>
>  synchronized可以加在三个不同的位置，对应三种不同的使用方式，这三种方式的区别是锁对象不同：
>
>1. 加在普通方法上，则锁是当前的实例（this）。
>
>2. 加在静态方法上，则锁是当前类的Class对象。
>
>3. 加在代码块上，则需要在关键字后面的小括号里，显式指定一个对象作为锁对象。
>
>  不同的锁对象，意味着不同的锁粒度，所以我们不应该无脑地将它加在方法前了事，尽管通常这可以解决问题。而是应该根据要锁定的范围，准确的选择锁对象，从而准确地确定锁的粒度，降低锁带来的性能开销。
>
>  synchronized是比较早期的API，在设计之初没有考虑到超时机制、非阻塞形式，以及多个条件变量。若想通过升级的方式让synchronized支持这些相对复杂的功能，则需要大改它的语法结构，不利于兼容旧代码。因此，JDK的开发团队在1.5引入了Lock，并通过Lock支持了上述的功能。Lock支持的功能包括：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。
>
>【加分回答】
>
>  synchronized采用“CAS+Mark Word”实现，为了性能的考虑，并通过锁升级机制降低锁的开销。在并发环境中，synchronized会随着多线程竞争的加剧，按照如下步骤逐步升级：无锁、偏向锁、轻量级锁、重量级锁。
>
>  Lock则采用“CAS+volatile”实现，其实现的核心是AQS。AQS是线程同步器，是一个线程同步的基础框架，它基于模板方法模式。在具体的Lock实例中，锁的实现是通过继承AQS来实现的，并且可以根据锁的使用场景，派生出公平锁、不公平锁、读锁、写锁等具体的实现。
>
>【延伸阅读】
>
>  想要保证线程安全，不止线程同步一种手段，还包含如下常见办法：
>
>1. 原子类：可以用原子方式更新一个变量，即在变量未被其他线程修改时才出发更新，否则会引发失败。
>
>2. volatile：volatile是一个轻量级的锁，它通过保证内存可见性的办法来实现线程安全。
>
>3. 并发工具：还有很多并发工具类，一样可以保证线程安全，如Semaphore、CountDownLatch、CyclicBarrier

### 内存溢出问题该如何解决



>#### 参考回答
>
>
>
>【得分点】
>
>  增加内存、错误日志、代码走查、内存查看工具
>
>【参考答案】
>
>标准回答
>
>  内存溢出，简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。引起内存溢出的原因有很多种，常见的有以下几种：
>
>1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
>
>2. 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
>
>3. 代码中存在死循环或循环产生过多重复的对象实体；
>
>4. 使用的第三方软件中的BUG；
>
>5. 启动参数内存值设定的过小。
>
>  内存溢出的解决方案：
>
>· 第一步，修改JVM启动参数，直接增加内存。
>
>· 第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。
>
>· 第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。
>
>· 第四步，使用内存查看工具动态查看内存使用情况。
>
>加分回答
>
>  除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM异常的可能。
>
>1. Java堆溢出
>
>Java堆用于储存对象实例，我们只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着对象数量的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。
>
>2. 虚拟机栈和本地方法栈溢出
>
>HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。
>
>3. 方法区和运行时常量池溢出
>
>方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了CGLib字节码增强和动态语言、大量JSP或动态产生JSP文件的应用、基于OSGi的应用等。
>
>在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，即常量池是方法去的一部分，所以上述问题在常量池中也同样会出现。而HotSpot从JDK 7开始逐步“去永久代”的计划，并在JDK 8中完全使用元空间来代替永久代，所以上述问题在JDK 8中会得到避免。
>
>4. 本地直接内存溢出
>
>直接内存的容量大小可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值一致。如果直接通过反射获取Unsafe实例进行内存分配，并超出了上述的限制时，将会引发OOM异常。