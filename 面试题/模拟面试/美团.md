# 第一次2022年6月7日09:27:06

## DNS（域名系统）是什么？

这个还是挺简单的

## 说一说HashMap的扩容机制

常规面试题哈，答了第一次是没有容量的，初次使用的时候会扩容，底层是数组＋链表+红黑树，将元素接入链表后，如果链表长度达到8，并且数组长度小于64，则扩容。但是对HashMap的底层实现不是很了解，想hashcode有没有重新计算之类的细节没有答上来

>**参考回答**
>
>【得分点】
>
>  三个条件、翻倍扩容
>
>【参考答案】
>
>标准回答
>
>  向HashMap中添加数据时，有三个条件会触发它的扩容行为：
>
>1. 如果数组为空，则进行首次扩容。
>
>2. 将元素接入链表后，如果链表长度达到8，并且数组长度小于64，则扩容。
>
>3. 添加后，如果数组中元素超过阈值，即比例超出限制（默认为0.75），则扩容。
>
>  每次扩容时都是将容量翻倍，即创建一个2倍大的新数组，然后再将旧数组中的数组迁移到新数组里。由于HashMap中数组的容量为2^N，所以可以用位移运算计算新容量，效率很高。
>
>加分回答
>
>  在数据迁移时，为了兼顾性能，不会重新计算一遍每个key的哈希值，而是根据位移运算后（左移翻倍）多出来的最高位来决定，如果高位为0则元素位置不变，如果高位为1则元素的位置是在原位置基础上加上旧的容量。
>
>  举个例子，来演示一下数据迁移时，元素在新数组里位置的判定。假设旧数组长度为16（00010000），则翻倍后新数组的长度为32（00100000）。我们从十进制数字上看不出什么，但是从二进制数字却可以看出二者的明显差别，即翻倍后新值的高位多了1。
>
>  如果我们把这两个值作为掩码，对key的哈希值做按位与运算，就能求出最高位那一位的差异。如果这一位是0则该元素的位置不变，否则该元素的位置就在原位置基础上加16。这个方式很巧妙，它省略了重新计算哈希值的时间，同时新增出来的一位是0或1是随机的，这样就把产生冲突的节点均匀的分散到新的槽里了。
>
>hash & (16-1) = hash & 00001111
>
>hash & (32-1) = hash & 00011111

## 介绍一下Java中的IO流

这里我讲了一下netty中的NIO

>**参考回答**
>
>【得分点】
>
>  输入流与输出流、字节流与字符流、节点流与处理流
>
>【参考答案】
>
>标准回答
>
>  流是Java对不同输入源输出源的抽象，代表了从起源到接收的有序数据，有了它程序就可以采用统一的方式来访问不同的输入源和输出源了。
>
>  按照数据的流向，可以将流分为输入流和输出流。其中，输入流只能读取数据、不能写入数据，而输出流只能写入数据、不能读取数据。
>
>  按照数据的类型，可以将流分为字节流和字符流。其中，字节流操作的数据单元是byte（8位的字节），而字符流操作的数据单元是char（16位的字符）。
>
>  按照使用的场景，可以将流分为节点流和处理流。其中，节点流可以直接从/向一个特定的IO设备读/写数据，也称为低级流。而处理流则是对节点流的连接或封装，用于简化数据读/写功能或提高效率，也成为高级流。
>
>  Java中的IO流主要有4个基类：InputStream、OutputStream、Reader、Writer。其中，InputStream代表字节输入流，OutputStream代表字节输出流，Reader代表字符输入流，Writer代表字符输出流。其他的IO流都是从这4个基类派生而来的，并且子类的名字往往以基类的名字结尾，所以通过类名我们很容易识别某个流的作用。
>
>  Java为我们提供了大量的IO流实现，我们没办法逐个介绍，下面举一些较为常用的例子：
>
>1. 用于访问文件的FileInputStream、FileOutputStream、FileReader、FileWriter。
>
>2. 带有缓冲功能的BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。
>
>3. 具有转换功能的InputStreamReader、OutputStreamWriter。
>
>4. 支持打印功能的PrintStream、PrintWriter。
>
>加分回答
>
>  Unix IO一共包含5种模型，分别是阻塞式IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO。Java的IO流实现是依附于平台的，换句话说它依赖于上述5种模型，实际上Java的IO流是基于阻塞式IO实现的。阻塞式IO是性能最差的IO模型了，所以Java的IO流并不是一个高效的实现，在Java的早期人们对Java性能的诟病也正源于此。
>
>  从1.4开始，Java提供了新的IO模型（NIO），这种IO模型是基于IO多路复用实现的。从1.7开始，Java又对IO模型进行了升级（NIO2），在本次升级中Java提供了异步IO模型（AIO）。这两种IO模型的引入，使得Java处理IO的性能大大的提高了，我们在处理IO问题时也应该尽量选择NIO，而少用IO流。
>
>【延伸阅读】
>
> 下表给大家整理了一些常用的类，黑色字体是抽象基类，红色字体是节点流，蓝色字体是处理流。
>
>![image-20220607093320460](https://cdn.fengxianhub.top/resources-master/202206070933679.png)

## 说一说你对Spring AOP的理解

回答的时候没有什么条例，而且两种代理忘记说了

>#### 参考回答
>
>【得分点】
>
>  概念、作用、实现
>
>【参考答案】
>
>标准回答
>
>  AOP是一种编程思想，是通过预编译方式和运行期动态代理的方式，在不修改源代码的情况下实现给程序动态统一添加功能的技术。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。
>
>  AOP技术利用一种称为“横切”的技术，剖解开封装对象的内部，将影响多个类的公共行为封装到一个可重用的模块中，并将其命名为切面。所谓的切面，简单来说就是与业务无关，却为业务模块所共同调用的逻辑，将其封装起来便于减少系统的重复代码，降低模块的耦合度，有利用未来的可操作性和可维护性。
>
>  利用AOP可以对业务逻辑各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。
>
>  AOP可以有多种实现方式，而Spring AOP支持如下两种实现方式。
>
>· JDK动态代理：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。
>
>· CGLib动态代理：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。
>
>加分回答
>
>  在应用场景方面，Spring AOP为IoC的使用提供了更多的便利。一方面，应用可以直接使用AOP的功能，设计应用的横切关注点，把跨越应用程序多个模块的功能抽象出来，并通过简单的AOP的使用，灵活地编制到模块中，比如可以通过AOP实现应用程序中的日志功能。另一方面，在Spring内部，例如事务处理之类的一些支持模块也是通过Spring AOP来实现的。
>
>AOP不能增强的类：
>
>1. Spring AOP只能对IoC容器中的Bean进行增强，对于不受容器管理的对象不能增强。
>
>2. 由于CGLib采用动态创建子类的方式生成代理对象，所以不能对final修饰的类进行代理。
>
>【延伸阅读】
>
>AOP的术语：
>
>· 连接点（join point）：对应的是具体被拦截的对象，因为 Spring 只能支持方法，所以被拦截的对象往往就是指特定的方法， AOP将通过动态代理技术把它织入对应的流程中。
>
>· 切点（point cut）：有时候，我们的切面不单单应用于单个方法，也可能是多个类的不同方法。这时，可以通过正则式和指示器的规则去定义，从而适配连接点。切点就是提供这样一个功能的概念。
>
>· 通知（advice）：就是按照约定的流程下的方法，分为前置通知（ befor advice ）、后置通知（ after advice ）、环绕通知 （around advice）、事后返回通知（afterRetuming advice）和异常通知 ( after Throwing advice ），它会根据约定织入流程中，需要弄明白它们在流程中的顺序和运行的条件。
>
>· 目标对象（target）：即被代理对象。
>
>· 引入（introduction）： 是指引入新的类和其方法，增强现有 Bean 的功能。
>
>· 织入（weaving）：它是一个通过动态代理技术，为原有服务对象生成代理对象然后将与切点定义匹配的连接点拦截，并按约定将各类通知织入约定流程的过程。
>
>· 切面（aspect）：是一个可以定义切点、各类通知和引入的内容，SpringAOP 将通过它的信息来增强 Bean 的功能或者将对应的方法织入流程。





























