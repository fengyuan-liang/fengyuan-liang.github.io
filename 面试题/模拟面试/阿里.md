## 第一次（2022年5月29日15:30:50）

### HTTPS协议对称加密的过程？

答的不好，虽然知道密钥通过非对称加密传输到客户端后再采用对称加密进行数据传输，但是一下子想不起来CA证书的验证过程了

答案：

client请求服务端（指定SSL版本和加密组件）
server返回CA证书+公钥
client用机构公钥认证server返回的CA证书上的签名是否正确
client生成一个密钥R，用公钥对密钥R加密发送给server server用服务器的私钥解密获取密钥R
后续通信都是采用密钥R进行加密

### JVM包含哪几部分？

JVM是我最不熟悉的地方可以说，所以这个题没答上来

答案：

JVM由三部分组成：类加载子系统、执行引擎、运行时数据区。

1. 类加载子系统，可以根据指定的全限定名来载入类或接口。
2. 执行引擎，负责执行那些包含在被载入类的方法中的指令。
3. 当程序运行时，JVM需要内存来存储许多内容，例如：字节码、对象、参数、返回值、局部变量、运算的中间结果，等等，JVM会把这些东西都存储到运行时数据区中，以便于管理。而运行时数据区又可以分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。

加分回答

  运行时数据区是开发者重点要关注的部分，因为程序的运行与它密不可分，很多错误的排查也需要基于对运行时数据区的理解。在运行时数据区所包含的几块内存空间中，方法区和堆是线程之间共享的内存区域，而虚拟机栈、本地方法栈、程序计数器则是线程私有的区域，就是说每个线程都有自己的这个区域。

### 说一说你对Spring IoC的理解

【得分点】

  控制反转、依赖注入

【参考答案】

标准回答

  IoC是控制反转的意思，是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高。尤其是在一个大型的项目中，对象与对象之间的关系是十分复杂的，这十分不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，并且降低对象之间的耦合度。

  说到IoC就不得不说DI，DI是依赖注入的意思，它是IoC实现的实现方式。由于IoC这个词汇比较抽象而DI比较直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。实现依赖注入的关键是IoC容器，它的本质就是一个工厂。

加分回答

  在以Spring为代表的轻量级Java EE开发风行之前，实际开发中是使用更多的是EJB为代表的开发模式。在EJB开发模式中，开发人员需要编写EJB组件，这种组件需要满足EJB规范才能在EJB容器中运行，从而完成获取事务，生命周期管理等基本服务。

  Spring提供的服务和EJB并没有什么区别，只是在具体怎样获取服务的方式上两者的设计有很大不同：Spring IoC提供了一个基本的JavaBean容器，通过IoC模式管理依赖关系，并通过依赖注入和AOP切面增强了为JavaBean服务于事务管理、生命周期管理等基本功能。

  而对于EJB，一个简单的EJB组件需要编写远程/本地接口、Home接口和Bean的实体类，而且EJB运行不能脱离EJB容器，查找其他EJB组件也需要通过诸如JNDI的方式，这就造成了对EJB容器和技术规范的依赖。也就是说Spring把EJB组件还原成了POJO对象或者JavaBean对象，以此降低了用用开发对于传统J2EE技术规范的依赖。

  在应用开发中开发人员设计组件时往往需要引用和调用其他组件的服务，这种依赖关系如果固化在组件设计中，会造成依赖关系的僵化和维护难度的增加，这个时候使用IoC把资源获取的方向反转，让IoC容器主动管理这些依赖关系，将这些依赖关系注入到组件中，这就会让这些依赖关系的适配和管理更加灵活。

【延伸阅读】

Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。

· BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。

· ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容 器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。

在具体的实现中，主要有三种注入方式：

\1. 构造方法注入

就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。

\2. setter方法注入

通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再注入。

\3. 接口注入

相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和繁琐。

  总体来说，构造方法注入和setter方法注入因为其侵入性较低，且易于理解和使用，所以是现在使用最多的注入方式。而接口注入因为侵入性较强，近年来已经不流行了。

### 算法题

输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

这个题我一看到就想用快慢指针来做，但是九个测试用例只能过六个，而且有点紧张，后面看了下力扣，可以用双指针并交换跑道的方式，这是最简单的，还有就是实在不会就用Set<>做也是一样的

![image-20220529161128408](https://cdn.fengxianhub.top/resources-master/202205291611586.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
         ListNode p1 = headA, p2 = headB;
         while(p1 != p2){
             p1 = p1 == null ? headB : p1.next;
             p2 = p2 == null ? headA : p2.next;
         }
         return p1;
    }
}
```

## 第二次（2022年6月27日08:09:49）

### 🎯说一说进程通信的方式有哪些？

我答的时候答的是通过tcp请求，后面发现完全不对

>#### 参考答案
>
>**标准回答**
>
>进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket：
>
>1. 管道
>
>   管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区，Linux 系统中通过 pipe() 函数创建管道，会生成两个文件描述符，分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。
>
>2. 命名管道
>
>   匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。
>
>3. 信号
>
>   信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
>
>4. 消息队列
>
>   消息队列就是一个消息的链表，可以把消息看作一个记录，具有特定的格式以及特定的优先级，对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程则可以从消息队列中读走消息，消息队列是随内核持续的。
>
>5. 共享内存
>
>   共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。
>
>6. 内存映射
>
>   内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件。
>
>7. 信号量
>
>   信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作，P 操作是将信号量的值减 1，V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后，再进行 P 操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。
>
>8. Socket
>
>   套接字（Socket），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。

### JVM包含哪几部分

上面有，答的时候只打了一点就是类装载子系统、字节码执行引擎、运行时数据区，没有往深处答了

### 说一说你对Spring IoC的理解

上面有



















