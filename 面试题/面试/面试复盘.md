## 北京朝夕一面

### 八股文

先从项目开始的，刚开始聊了一下怎么学习java的，学习方式：

>hdfs中存的是什么，小文件存在哪里？

小文件压缩

>redis实现点赞和排行榜怎么做的？具体的数据结构

**zset数据结构**

***SortedSet（zset）***是 ***Redis*** 提供的一个非常特别的数据结构，一方面它等价于 ***Java*** 的数据结构 ***Map<String, Double>***，可以给每一个元素 ***value*** 赋予一个权重 ***score***，另一方面它又类似于 ***TreeSet***，内部的元素会按照权重 ***score*** 进行排序，可以得到每个元素的名次，还可以通过 ***score*** 的范围来获取元素的列表。

***zset*** 底层使用了两个数据结构

- ***hash***，***hash*** 的作用就是关联元素 ***value*** 和权重 ***score***，保障元素 ***value*** 的唯一性，可以通过元素 ***value*** 找到相应的 ***score*** 值
- 跳跃表，跳跃表的目的在于给元素 ***value*** 排序，根据 ***score*** 的范围获取元素列表

>接口幂等性如何保证的，为什么用zookeeper分布式锁保证幂等性，怎么实现的？我回答了一点点，又问这样效率高吗？（面试官觉得这种做法不好）怎么优化? 

这样是将所有的请求串行化了，效率并不高

>zookeeper选举过程，详细说一下



>你刚才讲redis数据是存在内存中的，那么zk的数据存在哪里？磁盘还是内存？我答了内存又问那么zk的数据持久化怎么做的，会不会丢数据？和redis持久化的异同

zk数据是存在内存中的，然后也有类似于redis的内存快照和事物日志的持久化策略

>说一下常用的二叉树，红黑树和AVL树的那个更好？为什么，说一下各自的时间、空间复杂度



>HashMap桶的位置是怎么找到的？为什么用 & 不用 % ，为什么是(length - 1)，为什么要右移32位(一半)



>HashMap添加删除查询的时间复杂度和空间复杂度？你刚才说基于数组的，那么ArrayList的呢？



### 算法题

>一个任意长度的数组，里面装了任意个数字，数字可能是正数、负数和0，就该数组的子数组中积最大的子数组（前提是子数组中数据是连续的，不能跳跃）

动态规划：

```java

```

暴力破解（会超时）：

```java
public int maxAbsoluteSum(int[] nums) {
    int maxNum = 0;
    for (int i = 0; i < nums.length; i++) {
        int cnt = 0;
        for (int j = i; j < nums.length; j++) {
            cnt = cnt + nums[j];
            maxNum = Math.max(maxNum, Math.abs(cnt));
        }
    }
    return maxNum;
}
```

>两张表，用户表和关系表，用户表中有用户id，关系表中有用户的朋友id，查出朋友最多的前十个用户并输出信息

```sql
select * from user where uid in(
	select uid from (
    	select u.uid,count(1) cnt from user u,relationship r where u left join r group by u.uid
    ) order by cnt desc
) limit 10;
```

## 蔚来笔试

### 选择题

考了好多c++，还有操作系统，还有一些Linux的命令，10道单选，5道多选

记得有一个问：cat /proc/cpuinfo |grep "processor"|wc -l | xargs 输出什么？

![image-20220716204445337](https://cdn.fengxianhub.top/resources-master/202207162044461.png)

查看逻辑CPU个数

C++中下面构造函数的执行顺序

```java
class father{
    father(){
        // 1
    }
    _destroy_father(){
        // 4
    }
}
class son extends father{
    son(){
        // 2
    }
    _desory_son(){
        // 3
    }
}
main(){
    new son();
}
```

### 算法题

算法1：

https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&ru=/exam/oj

有一个链表，要求将其中重复的结点去掉，例如

```java
1 -> 2 -> 3 -> 4 -> 5 -> 5 -> 6
```

```java
1 -> 2 -> 3 -> 4 -> 6
```

例如：

```java
1 -> 1 -> 1 -> 4 -> 5 -> 5 -> 6
```

```java
4 -> 6
```

解题思路：

- 首先要构建一个虚拟的头结点，防止前几个结点重复的情况发生
- pre指针应该指向一定不会重复的那个结点，刚开始应该指向我们虚拟的头结点
- last指针是用来移动并判断是否有重复结点的指针

```java
public static ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) return head;
    // dummy用来标记头结点之前的结点，防止前面元素相同的情况
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // pre用来标记一定不会重复的元素
    ListNode pre = dummy;
    // last用来标记当前正在移动并且进行比较的指针
    ListNode last = dummy.next;
    while (last != null) {
        if (last.next != null && last.val == last.next.val) {
            // 说明结点相同，跳过所有相同的结点
            while (last.next != null && last.val == last.next.val) {
                last = last.next;
            }
            // 让前一个一定不会重复的指针指向现在的last
            pre.next = last.next;
        } else {
            // 这里表示结点不同，正常往后移动
            pre = pre.next;
        }
        last = last.next;
    }
    return dummy.next;
}
```

算法2（有效的括号升级版）：

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'`，`*` 的字符串 `s` ，判断字符串是否有效，其中`*`表示任意字符，包括空字符

```java
输入：s = "()"
输出：true
输入：s = "(*"
输出：true
输入：s = "*)"
输出：true
输入：s = "*))"
输出：false
输入：s = "*"
输出：true
输入：s = "()*]*]"
输出：true
```

思路：

- 首先遇到左边的括号将其入栈
- 遇到右边的括号出栈一个元素进行比较，不匹配直接false
- 由于 * 表示任意符号，所以要单独处理

```java
public static boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    // 拿到字符数组
    char[] chars = s.toCharArray();
    for (char c : chars) {
        if (c == '(' || c == '{' || c == '[') {
            // 入栈
            stack.push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            // 出栈
            if (stack.isEmpty()) return false;
            char pop = stack.pop();
            // 如果是 * ，可以匹配任意字符，直接跳过
            if (pop == '*') continue;
            if (c == ')' && pop != '(') {
                return false;
            } else if (c == ']' && pop != '[') {
                return false;
            } else if (c == '}' && pop != '{') {
                return false;
            }
        } else {
            // char为 * 的情况，这种要单独进行处理
            // 如果栈为空，将*入栈
            if (stack.isEmpty()) {
                stack.push(c);
            } else {
                // 因为 * 可以匹配任意符号，所以直接出栈一个符号
                stack.pop();
            }
        }
    }
    return stack.isEmpty() || stack.contains('*');
}
```

算法3：有一点点坑的二叉树中序遍历

```java
/**
 * 中序遍历（递归实现）
 */
private void inorderTraversal(Node<E> node) {
    if (node == null) return;
    inorderTraversal(node.left, visitor);
    //业务逻辑，例如输出一句话
    System.out.println(node.val);
    inorderTraversal(node.right, visitor);
}

/**
 * 中序栈实现
 */
private void inorderTraversalByStack(Node<E> node) {
    //只要左结点存在就一直入栈
    while (true) {
        if (node != null) {
            stack.push(node);
            node = node.left;
        } else {
            if (stack.isEmpty()) return;
            node = stack.pop();
            //业务逻辑，例如输出一句话
            System.out.println(node.val);
            node = node.right;
        }
    }
}
```

### 朋友的笔试

```css
算法1：
题目描述
小红可以对一个数进行如下两种操作:将这个数乘以x;或将这个数乘以y操作的次数是没有限制的。
小红想知道，自己最少经过多少次操作以后，可以把a变成b?

输入描述:
四个正整数 x,y,a,b，用空格隔开。2 ≤ x,y ≤ 100 1≤a,b ≤ 109

输出描述:
如果小红无论如何都无法把a变成b，则输出-1.
否则输出小红操作的最少次数。可以证明，如果存在某种操作，那么最少次数一定是固定的。
```



```java
算法2：
题目描述
牛牛对n个城市的旅游情况进行了规划
已知每个城市有两种属性x和y，其中x表示去第号城市的花费表示在第号城市游玩后会得到的开心值，现在生生希望从中挑选出一些城市去游玩，但挑选出的城市必须满足任意两个城市之间花费的绝对值小于k，他想请你帮他计算出在满足上述条件下能得到的最大开心值是多少
    
输入描述:
第一行输入两个正整数n和k.
接下来n行.每行输入两个整数xi和yi分别表示每个城市的两种属性。1<n<100000
1 < k < 1000000000
0 ≤ xi,yi ≤ 1000000000
    
输出描述:
输出一个整数表示答案。
```

```java
算法3：
题目描述
生牛有一个nxm的矩阵，牛生想要找一个子方阵，方阵的大小为lxl且 l>2，这个方阵的价值为其四个角上数字之和。牛生想求价值最大的子方阵，请你告诉牛生这个子方阵的价值。
    
输入描述:
第一行为两个数n，m，表示表示矩阵大小。接下来有n行，每行有m个数 aijo2 ≤ n,m ≤ 10²,1 ≤ aij ≤ 109
    
输出描述:
输出为一行，表示答案。
```

```java
class father{
    father(){
     // 1   
    }
    _destory_father(){
        // 4
    }
}
class son extends father{
    son(){
        // 2
    }
     _destory_father(){
        // 3
    }
}
main{
    new son();
}
```



## 爱的番茄一面

1. hadoop HA结点中多个NameNode的职能（active、standby结点）
2. hadoop HA集群如何做到高可用，集群容灾处理过程？
3. MapReduce过程？ForkJoin过程？
4. 布隆过滤器底层实现原理？布隆过滤器的优点和缺点，这里面试官有一个问题我觉得还比较有意思，**问布隆过滤器如何降低失误率**，我回答手动调整那个失误率的参数，面试官微微一笑🤣，然后就答不会了
5. redis所有数据结构背一下，还有底层实现也背一下（五种基本+三种新增的）
6. redis zset为什么使用跳表而不使用红黑树
7. redis对key做范围查找怎么做？我答了通配符和`keys *`，面试官问用通配符有什么缺点？（这个我是真不知道）
8. redis集群类型 ?（哨兵+分片）, 集群之间数据如何同步，同步过程？（全量同步RDB + 增量同步AOF）
9. ...Redis问了好多，还问了一些命令，就是在黑框框里面输入的那个玩意
10. Mysql了解多少？答：没了解多少。聚集索引非聚集索引区别背一下
11. 联合索引索引失效的场景有哪些？最左原则是什么？如何保证
12. 索引下推是什么你知道吗？**索引建的越多越好吗**？（我回答不是，面试官问我为什么？你讲一下索引如何建比较好？我没答上来😭）
13. 线程同步方式？
14. JDK中的锁有哪些？背一下
15. 线程池的七个参数背一下，阻塞队列背一下，拒绝策略背一下
16. 线程池的核心线程数和最大线程数如何设置？我答了按cpu设置，核心为cpu核心数，最大为cpu核心数两倍；然后还答了一个IO密集型和计算密集型下要提高和降低比例（这里回答反了，面试官当场纠正我🤣，社死）
17. MogoDB有了解过吗？答：没有
18. netty有了解过吗？答：没有😂，然后我回答了一下BIO/NIO的区别和IO多路复用的原理，感觉还是要扯一点的🤣
19. 有玩过实时语音的游戏嘛？答：没有，吃鸡时候找陪玩的时候用过比心❤，其他没用过了。面试官说小伙子不能整天敲代码嘛，游戏还是要玩一些的，我们公司就是做游戏的，如果让你做一款实时语音的游戏你要怎么做？？？？😫我回答用Spark做流式计算，用netty做实时通讯
20. 看你八股文背的还挺熟练的，算法题下一次再给你做叭，你有什么想问我的？问：贵公司的技术栈，答：SpringBoot + MogoDB + 一系列中间件

## 爱的番茄二面

1. 我是公司的技术总监，我先简单介绍一下自己 。。。 你也介绍一下自己
2. 介绍下你的项目？最难的点有哪些
3. 你的项目微服务结构如何设计的？如何做到高可用、高并发
4. 后面基本上都是挖项目
5. ... 项目挖完了之后开始问一些别的
6. 说一个时事新闻，非技术相关的 ？？？🤨🤨🤨我回答了俄乌大战对世界经济的影响
7. 为什么要学大数据？
8. 未来三到五年的职业规划
9. 来了公司时候你想要学习那些新技术。我回答了想用netty写一个高性能的RPC框架，还有就是把大数据其他组件再好好学一下
10. 你有什么想问我的吗？答：没有

## 大疆笔试

五道单选 + 五道多选 + 两个概述 + 一道算法

**概述题一：如果设计一个高性能的RPC框架？**

我把Dubbo的基本思路写了一下，主要在`序列化`和`网络通信`两个方面，还写了一下Dubbo中的五个基本模块/角色

- Container： 服务运行容器，负责加载、运行服务提供者

- Provider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务
- Consumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务
- Registry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者
- Monitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心

**概述题二：下面加锁方式的代码有什么不好**

代码是CPP的，没怎么看懂，答了不能堵塞式的进行加锁，应该采用`tryLock`方式，也就是`cas + 自旋`的方式，避免出现`死锁、饥饿和活锁`的情况

算法题：

![image-20220807200806604](https://s2.loli.net/2022/08/07/NDu4nScFIQUAygx.png)

怎么刚开始没搞清楚怎么作答，弄到最后几分钟才搞清楚作答的方式😣（给爷搞吐了，大疆能不能长点心）

没时间了直接一波暴力，过了60%

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // 从键盘中拿到输入的数组
        Scanner cin = new Scanner(System.in);
        ArrayList<Integer> arr = new ArrayList<>();
        while (cin.hasNextLine()) {
            String line = cin.nextLine();
            if (line.length() > 0) {
                String[] arrLine = line.split(" ");
                for (int i = 0; i < arrLine.length; i++) {
                    arr.add(Integer.parseInt(arrLine[i]));
                }
            }
        }
        // 调用函数拿到对应的数字
        int max = getMaxSum(arr);
        System.out.println(max);
    }

    static int getMaxSum(ArrayList<Integer> arr) {
        int var1 = 0, var2 = 0, maxSum = 0;
        for (int i = 0; i < arr.size(); i++) {
            for (int j = i + 1; j < arr.size(); j++) {
                if (arr.get(i) + arr.get(j) >= maxSum && j - i >= 2) {
                    var1 = i;
                    var2 = j;
                    maxSum = arr.get(var1) + arr.get(var2);
                }
            }
        }
        return arr.get(var1) + arr.get(var2);
    }
}
```



## 古茗

### 古茗笔试

记不得太多了，有一些Java基础题、操作系统和计算机网络

算法题：

给几个字符串，用一个容器装起来，保证字符不重复（有点像set），请设计这个容器，要求是你认为时间复杂度最低的，并且写出分析时间复杂度计算过程

思路：看到时间复杂度最低，首先想到的是字典（Hash表），可以采用空间换时间的思路

```java
public class Container {
	// 这里底层直接维护一个HashMap，也可以自己写一个简单的字典
	// Void 是void的包装类型，常用填充泛型，表示是没有返回值
	Map<Char,Void> map = new HashMap<>();
	public boolean contains(char c){
		return map.containsKey(c);
	}

	public boolean add(char c){
		return map.put(c,null)
	}
	
}
```


### 古茗一面

1. 先介绍下你的项目
2. 你的Hadoop集群是如何实现动态扩容的
3. 项目中缓存链是如何设计的？为什么要设计四层缓存链，你的项目有这么大的并发量吗？部署了几个节点，接口QPS是多少？
4. 操作系统管理内存的方式？JVM内存管理？
5. 讲一下JVM分配内存的过程
6. 讲一个你最熟悉的垃圾回收器，讲一下它的垃圾回收过程
7. OSI七层模型是哪七层？每一层有哪些常用协议（笑死问我一个网络的网络，我直接【橙白橙绿白蓝蓝白绿棕白棕】）
8. 三次握手过程？为什么不是两次、四次
9. 讲一下操作系统段页式索引结构
10. 讲一下MySQL InnoDB引擎的特点
11. InnoDB和MyISAM索引的区别（B+树的区别）
12. InnoDB索引结构？你刚才说了页（Page），详细讲一下page的结构（记得不是很清楚了，好久没复习😭）
![](https://cdn.fengxianhub.top/resources-master/20220826102631.png)
13. 你在实习中使用的技术栈，有哪些收获？答：学会了被老板PUA

## 小红书

### 笔试

20选择 + 3道算法

**算法一**

在遥远的国度有一位国王，他每天的工作都十分繁忙，因为每天都有许多大臣来向他汇报各种信息等。这天有n位大臣来汇报信息，其中第i位的序号为i，为了更有效的完成每天的工作，国王决定给每位大臣汇报的事情按重要性进行一个排序，让各位大臣按排序依次汇报。首先对每人的汇报在m个方面各评估一个重要性，然后每个汇报的重要性就是m个方面的重要性之和，重要性越高的汇报会排在越前面，对于重要性相同的，则按大臣的序号排序，越小的在越前面。这时，序号为id的大臣找到了你，他想请你帮他计算一下他排在第几个。

```java
输出一行一个正整数ans，表示序号为i的大臣排在第ans位。
样例输入：
3 3 2
90 90 90
80 100 90
80 85 85
输出：2
```

**算法二**

小明是一名魔法师，他会n种法术，其中第i种法术的威力为ai，他经常通过双手各自释放一种法术来提升威力，能得到的威力值为双手各自释放的法术的威力的乘积，但是他还不够强大，双手释放的两种法术必须是不同的，即不能双手释放同一种法术。这天他接到了一个任务，需要释放威力值至少为K才能完成，他想请你帮他算一算，在两只手都释放法术的情况下，共有多少方案能达到威力值K。每种方案可记作（u，v），u≠v，其威力值为au * av，（u，v）和（v，u）会被视为不同的方案

```java
第二行为n个正整数a1, a2,...... an，其中ai表示第i个法术的威力为ai。
    
输出威力值至少为K的方案数
```

**算法三**

某公司正在组织新员工团建，其中一项活动是两两配对进行石头剪刀布。
因为新员工来自不同的学校和专业，他们许多人之间并不熟悉，但他们之间的朋友关系形成了一棵树。即若将朋友关系描述为一张无向图，则这张无向图中任意两点之间有且仅有一条路径。为了避免尴尬，组织者希望互为朋友的配对数量尽可能多。现在他希望你求出互为朋友的配对数量最多能有多少

```java
第一行有一个偶数n(2<=n<=1000)，代表有n个新员工。
第二行有n-1个空格隔开的数，第i个数ai代表编号为i+1的新员工与编号为ai的员工互为朋友。
输入保证新员工之间的朋友关系形成了一棵树
输出在所有可能的配对方案中，互为朋友的配对数量最多是多少。
输入:
6
1 2 2 3 3
输出 : 2
如样例中，一共有6个新员工，朋友关系有以下五个(1,2),(2,3),(2,4),(3,5),(3,6)。
可以证明无论如何匹配这6个人， 最多只能有两对是互为朋友的，因此输出2。
```















