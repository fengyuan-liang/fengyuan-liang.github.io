## 北京朝夕一面

### 八股文

先从项目开始的，刚开始聊了一下怎么学习java的，学习方式：

> hdfs中存的是什么，小文件存在哪里？

小文件压缩

> redis实现点赞和排行榜怎么做的？具体的数据结构

**zset数据结构**

***SortedSet（zset）***是 ***Redis*** 提供的一个非常特别的数据结构，一方面它等价于 ***Java*** 的数据结构 ***Map<String, Double>***，可以给每一个元素 ***value*** 赋予一个权重 ***score***，另一方面它又类似于 ***TreeSet***，内部的元素会按照权重 ***score*** 进行排序，可以得到每个元素的名次，还可以通过 ***score*** 的范围来获取元素的列表。

***zset*** 底层使用了两个数据结构

- ***hash***，***hash*** 的作用就是关联元素 ***value*** 和权重 ***score***，保障元素 ***value*** 的唯一性，可以通过元素 ***value*** 找到相应的 ***score*** 值
- 跳跃表，跳跃表的目的在于给元素 ***value*** 排序，根据 ***score*** 的范围获取元素列表

> 接口幂等性如何保证的，为什么用zookeeper分布式锁保证幂等性，怎么实现的？我回答了一点点，又问这样效率高吗？（面试官觉得这种做法不好）怎么优化? 

这样是将所有的请求串行化了，效率并不高

> zookeeper选举过程，详细说一下

> 你刚才讲redis数据是存在内存中的，那么zk的数据存在哪里？磁盘还是内存？我答了内存又问那么zk的数据持久化怎么做的，会不会丢数据？和redis持久化的异同

zk数据是存在内存中的，然后也有类似于redis的内存快照和事物日志的持久化策略

> 说一下常用的二叉树，红黑树和AVL树的那个更好？为什么，说一下各自的时间、空间复杂度

> HashMap桶的位置是怎么找到的？为什么用 & 不用 % ，为什么是(length - 1)，为什么要右移32位(一半)

> HashMap添加删除查询的时间复杂度和空间复杂度？你刚才说基于数组的，那么ArrayList的呢？

### 算法题

> 一个任意长度的数组，里面装了任意个数字，数字可能是正数、负数和0，就该数组的子数组中积最大的子数组（前提是子数组中数据是连续的，不能跳跃）

动态规划：

```java

```

暴力破解（会超时）：

```java
public int maxAbsoluteSum(int[] nums) {
    int maxNum = 0;
    for (int i = 0; i < nums.length; i++) {
        int cnt = 0;
        for (int j = i; j < nums.length; j++) {
            cnt = cnt + nums[j];
            maxNum = Math.max(maxNum, Math.abs(cnt));
        }
    }
    return maxNum;
}
```

> 两张表，用户表和关系表，用户表中有用户id，关系表中有用户的朋友id，查出朋友最多的前十个用户并输出信息

```sql
select * from user where uid in(
    select uid from (
        select u.uid,count(1) cnt from user u,relationship r where u left join r group by u.uid
    ) order by cnt desc
) limit 10;
```

## 蔚来笔试

### 选择题

考了好多c++，还有操作系统，还有一些Linux的命令，10道单选，5道多选

记得有一个问：cat /proc/cpuinfo |grep "processor"|wc -l | xargs 输出什么？

![image-20220716204445337](https://cdn.fengxianhub.top/resources-master/202207162044461.png)

查看逻辑CPU个数

C++中下面构造函数的执行顺序

```java
class father{
    father(){
        // 1
    }
    _destroy_father(){
        // 4
    }
}
class son extends father{
    son(){
        // 2
    }
    _desory_son(){
        // 3
    }
}
main(){
    new son();
}
```

### 算法题

算法1：

https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&ru=/exam/oj

有一个链表，要求将其中重复的结点去掉，例如

```java
1 -> 2 -> 3 -> 4 -> 5 -> 5 -> 6
```

```java
1 -> 2 -> 3 -> 4 -> 6
```

例如：

```java
1 -> 1 -> 1 -> 4 -> 5 -> 5 -> 6
```

```java
4 -> 6
```

解题思路：

- 首先要构建一个虚拟的头结点，防止前几个结点重复的情况发生
- pre指针应该指向一定不会重复的那个结点，刚开始应该指向我们虚拟的头结点
- last指针是用来移动并判断是否有重复结点的指针

```java
public static ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) return head;
    // dummy用来标记头结点之前的结点，防止前面元素相同的情况
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // pre用来标记一定不会重复的元素
    ListNode pre = dummy;
    // last用来标记当前正在移动并且进行比较的指针
    ListNode last = dummy.next;
    while (last != null) {
        if (last.next != null && last.val == last.next.val) {
            // 说明结点相同，跳过所有相同的结点
            while (last.next != null && last.val == last.next.val) {
                last = last.next;
            }
            // 让前一个一定不会重复的指针指向现在的last
            pre.next = last.next;
        } else {
            // 这里表示结点不同，正常往后移动
            pre = pre.next;
        }
        last = last.next;
    }
    return dummy.next;
}
```

算法2（有效的括号升级版）：

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'`，`*` 的字符串 `s` ，判断字符串是否有效，其中`*`表示任意字符，包括空字符

```java
输入：s = "()"
输出：true
输入：s = "(*"
输出：true
输入：s = "*)"
输出：true
输入：s = "*))"
输出：false
输入：s = "*"
输出：true
输入：s = "()*]*]"
输出：true
```

思路：

- 首先遇到左边的括号将其入栈
- 遇到右边的括号出栈一个元素进行比较，不匹配直接false
- 由于 * 表示任意符号，所以要单独处理

```java
public static boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    // 拿到字符数组
    char[] chars = s.toCharArray();
    for (char c : chars) {
        if (c == '(' || c == '{' || c == '[') {
            // 入栈
            stack.push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            // 出栈
            if (stack.isEmpty()) return false;
            char pop = stack.pop();
            // 如果是 * ，可以匹配任意字符，直接跳过
            if (pop == '*') continue;
            if (c == ')' && pop != '(') {
                return false;
            } else if (c == ']' && pop != '[') {
                return false;
            } else if (c == '}' && pop != '{') {
                return false;
            }
        } else {
            // char为 * 的情况，这种要单独进行处理
            // 如果栈为空，将*入栈
            if (stack.isEmpty()) {
                stack.push(c);
            } else {
                // 因为 * 可以匹配任意符号，所以直接出栈一个符号
                stack.pop();
            }
        }
    }
    return stack.isEmpty() || stack.contains('*');
}
```

算法3：有一点点坑的二叉树中序遍历

```java
/**
 * 中序遍历（递归实现）
 */
private void inorderTraversal(Node<E> node) {
    if (node == null) return;
    inorderTraversal(node.left, visitor);
    //业务逻辑，例如输出一句话
    System.out.println(node.val);
    inorderTraversal(node.right, visitor);
}

/**
 * 中序栈实现
 */
private void inorderTraversalByStack(Node<E> node) {
    //只要左结点存在就一直入栈
    while (true) {
        if (node != null) {
            stack.push(node);
            node = node.left;
        } else {
            if (stack.isEmpty()) return;
            node = stack.pop();
            //业务逻辑，例如输出一句话
            System.out.println(node.val);
            node = node.right;
        }
    }
}
```

### 朋友的笔试

```css
算法1：
题目描述
小红可以对一个数进行如下两种操作:将这个数乘以x;或将这个数乘以y操作的次数是没有限制的。
小红想知道，自己最少经过多少次操作以后，可以把a变成b?

输入描述:
四个正整数 x,y,a,b，用空格隔开。2 ≤ x,y ≤ 100 1≤a,b ≤ 109

输出描述:
如果小红无论如何都无法把a变成b，则输出-1.
否则输出小红操作的最少次数。可以证明，如果存在某种操作，那么最少次数一定是固定的。
```

```java
算法2：
题目描述
牛牛对n个城市的旅游情况进行了规划
已知每个城市有两种属性x和y，其中x表示去第号城市的花费表示在第号城市游玩后会得到的开心值，现在生生希望从中挑选出一些城市去游玩，但挑选出的城市必须满足任意两个城市之间花费的绝对值小于k，他想请你帮他计算出在满足上述条件下能得到的最大开心值是多少

输入描述:
第一行输入两个正整数n和k.
接下来n行.每行输入两个整数xi和yi分别表示每个城市的两种属性。1<n<100000
1 < k < 1000000000
0 ≤ xi,yi ≤ 1000000000

输出描述:
输出一个整数表示答案。
```

```java
算法3：
题目描述
生牛有一个nxm的矩阵，牛生想要找一个子方阵，方阵的大小为lxl且 l>2，这个方阵的价值为其四个角上数字之和。牛生想求价值最大的子方阵，请你告诉牛生这个子方阵的价值。

输入描述:
第一行为两个数n，m，表示表示矩阵大小。接下来有n行，每行有m个数 aijo2 ≤ n,m ≤ 10²,1 ≤ aij ≤ 109

输出描述:
输出为一行，表示答案。
```

```java
class father{
    father(){
     // 1   
    }
    _destory_father(){
        // 4
    }
}
class son extends father{
    son(){
        // 2
    }
     _destory_father(){
        // 3
    }
}
main{
    new son();
}
```

## 爱的番茄一面

1. hadoop HA结点中多个NameNode的职能（active、standby结点）
2. hadoop HA集群如何做到高可用，集群容灾处理过程？
3. MapReduce过程？ForkJoin过程？
4. 布隆过滤器底层实现原理？布隆过滤器的优点和缺点，这里面试官有一个问题我觉得还比较有意思，**问布隆过滤器如何降低失误率**，我回答手动调整那个失误率的参数，面试官微微一笑🤣，然后就答不会了
5. redis所有数据结构背一下，还有底层实现也背一下（五种基本+三种新增的）
6. redis zset为什么使用跳表而不使用红黑树
7. redis对key做范围查找怎么做？我答了通配符和`keys *`，面试官问用通配符有什么缺点？（这个我是真不知道）
8. redis集群类型 ?（哨兵+分片）, 集群之间数据如何同步，同步过程？（全量同步RDB + 增量同步AOF）
9. ...Redis问了好多，还问了一些命令，就是在黑框框里面输入的那个玩意
10. Mysql了解多少？答：没了解多少。聚集索引非聚集索引区别背一下
11. 联合索引索引失效的场景有哪些？最左原则是什么？如何保证
12. 索引下推是什么你知道吗？**索引建的越多越好吗**？（我回答不是，面试官问我为什么？你讲一下索引如何建比较好？我没答上来😭）
13. 线程同步方式？
14. JDK中的锁有哪些？背一下
15. 线程池的七个参数背一下，阻塞队列背一下，拒绝策略背一下
16. 线程池的核心线程数和最大线程数如何设置？我答了按cpu设置，核心为cpu核心数，最大为cpu核心数两倍；然后还答了一个IO密集型和计算密集型下要提高和降低比例（这里回答反了，面试官当场纠正我🤣，社死）
17. MogoDB有了解过吗？答：没有
18. netty有了解过吗？答：没有😂，然后我回答了一下BIO/NIO的区别和IO多路复用的原理，感觉还是要扯一点的🤣
19. 有玩过实时语音的游戏嘛？答：没有，吃鸡时候找陪玩的时候用过比心❤，其他没用过了。面试官说小伙子不能整天敲代码嘛，游戏还是要玩一些的，我们公司就是做游戏的，如果让你做一款实时语音的游戏你要怎么做？？？？😫我回答用Spark做流式计算，用netty做实时通讯
20. 看你八股文背的还挺熟练的，算法题下一次再给你做叭，你有什么想问我的？问：贵公司的技术栈，答：SpringBoot + MogoDB + 一系列中间件

## 爱的番茄二面

1. 我是公司的技术总监，我先简单介绍一下自己 。。。 你也介绍一下自己
2. 介绍下你的项目？最难的点有哪些
3. 你的项目微服务结构如何设计的？如何做到高可用、高并发
4. 后面基本上都是挖项目
5. ... 项目挖完了之后开始问一些别的
6. 说一个时事新闻，非技术相关的 ？？？🤨🤨🤨我回答了俄乌大战对世界经济的影响
7. 为什么要学大数据？
8. 未来三到五年的职业规划
9. 来了公司时候你想要学习那些新技术。我回答了想用netty写一个高性能的RPC框架，还有就是把大数据其他组件再好好学一下
10. 你有什么想问我的吗？答：没有

## 大疆笔试

五道单选 + 五道多选 + 两个概述 + 一道算法

**概述题一：如果设计一个高性能的RPC框架？**

我把Dubbo的基本思路写了一下，主要在`序列化`和`网络通信`两个方面，还写了一下Dubbo中的五个基本模块/角色

- Container： 服务运行容器，负责加载、运行服务提供者

- Provider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务

- Consumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务

- Registry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者

- Monitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心

**概述题二：下面加锁方式的代码有什么不好**

代码是CPP的，没怎么看懂，答了不能堵塞式的进行加锁，应该采用`tryLock`方式，也就是`cas + 自旋`的方式，避免出现`死锁、饥饿和活锁`的情况

算法题：

![image-20220807200806604](https://s2.loli.net/2022/08/07/NDu4nScFIQUAygx.png)

怎么刚开始没搞清楚怎么作答，弄到最后几分钟才搞清楚作答的方式😣（给爷搞吐了，大疆能不能长点心）

没时间了直接一波暴力，过了60%

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // 从键盘中拿到输入的数组
        Scanner cin = new Scanner(System.in);
        ArrayList<Integer> arr = new ArrayList<>();
        while (cin.hasNextLine()) {
            String line = cin.nextLine();
            if (line.length() > 0) {
                String[] arrLine = line.split(" ");
                for (int i = 0; i < arrLine.length; i++) {
                    arr.add(Integer.parseInt(arrLine[i]));
                }
            }
        }
        // 调用函数拿到对应的数字
        int max = getMaxSum(arr);
        System.out.println(max);
    }

    static int getMaxSum(ArrayList<Integer> arr) {
        int var1 = 0, var2 = 0, maxSum = 0;
        for (int i = 0; i < arr.size(); i++) {
            for (int j = i + 1; j < arr.size(); j++) {
                if (arr.get(i) + arr.get(j) >= maxSum && j - i >= 2) {
                    var1 = i;
                    var2 = j;
                    maxSum = arr.get(var1) + arr.get(var2);
                }
            }
        }
        return arr.get(var1) + arr.get(var2);
    }
}
```

## 古茗

### 古茗笔试

记不得太多了，有一些Java基础题、操作系统和计算机网络

算法题：

给几个字符串，用一个容器装起来，保证字符不重复（有点像set），请设计这个容器，要求是你认为时间复杂度最低的，并且写出分析时间复杂度计算过程

思路：看到时间复杂度最低，首先想到的是字典（Hash表），可以采用空间换时间的思路

```java
public class Container {
    // 这里底层直接维护一个HashMap，也可以自己写一个简单的字典
    // Void 是void的包装类型，常用填充泛型，表示是没有返回值
    Map<Char,Void> map = new HashMap<>();
    public boolean contains(char c){
        return map.containsKey(c);
    }

    public boolean add(char c){
        return map.put(c,null)
    }

}
```

### 古茗一面

1. 先介绍下你的项目
2. 你的Hadoop集群是如何实现动态扩容的
3. 项目中缓存链是如何设计的？为什么要设计四层缓存链，你的项目有这么大的并发量吗？部署了几个节点，接口QPS是多少？
4. 操作系统管理内存的方式？JVM内存管理？
5. 讲一下JVM分配内存的过程
6. 讲一个你最熟悉的垃圾回收器，讲一下它的垃圾回收过程
7. OSI七层模型是哪七层？每一层有哪些常用协议（笑死问我一个网络的网络，我直接【橙白橙绿白蓝蓝白绿棕白棕】）
8. 三次握手过程？为什么不是两次、四次
9. 讲一下操作系统段页式索引结构
10. 讲一下MySQL InnoDB引擎的特点
11. InnoDB和MyISAM索引的区别（B+树的区别）
12. InnoDB索引结构？你刚才说了页（Page），详细讲一下page的结构（记得不是很清楚了，好久没复习😭）
    ![](https://cdn.fengxianhub.top/resources-master/20220826102631.png)
13. 你在实习中使用的技术栈，有哪些收获？答：学会了被老板PUA

## 小红书

### 笔试

20选择 + 3道算法

**算法一**

在遥远的国度有一位国王，他每天的工作都十分繁忙，因为每天都有许多大臣来向他汇报各种信息等。这天有n位大臣来汇报信息，其中第i位的序号为i，为了更有效的完成每天的工作，国王决定给每位大臣汇报的事情按重要性进行一个排序，让各位大臣按排序依次汇报。首先对每人的汇报在m个方面各评估一个重要性，然后每个汇报的重要性就是m个方面的重要性之和，重要性越高的汇报会排在越前面，对于重要性相同的，则按大臣的序号排序，越小的在越前面。这时，序号为id的大臣找到了你，他想请你帮他计算一下他排在第几个。

```java
输出一行一个正整数ans，表示序号为i的大臣排在第ans位。
样例输入：
3 3 2
90 90 90
80 100 90
80 85 85
输出：2
```

**算法二**

小明是一名魔法师，他会n种法术，其中第i种法术的威力为ai，他经常通过双手各自释放一种法术来提升威力，能得到的威力值为双手各自释放的法术的威力的乘积，但是他还不够强大，双手释放的两种法术必须是不同的，即不能双手释放同一种法术。这天他接到了一个任务，需要释放威力值至少为K才能完成，他想请你帮他算一算，在两只手都释放法术的情况下，共有多少方案能达到威力值K。每种方案可记作（u，v），u≠v，其威力值为au * av，（u，v）和（v，u）会被视为不同的方案

```java
第二行为n个正整数a1, a2,...... an，其中ai表示第i个法术的威力为ai。

输出威力值至少为K的方案数
```

**算法三**

某公司正在组织新员工团建，其中一项活动是两两配对进行石头剪刀布。
因为新员工来自不同的学校和专业，他们许多人之间并不熟悉，但他们之间的朋友关系形成了一棵树。即若将朋友关系描述为一张无向图，则这张无向图中任意两点之间有且仅有一条路径。为了避免尴尬，组织者希望互为朋友的配对数量尽可能多。现在他希望你求出互为朋友的配对数量最多能有多少

```java
第一行有一个偶数n(2<=n<=1000)，代表有n个新员工。
第二行有n-1个空格隔开的数，第i个数ai代表编号为i+1的新员工与编号为ai的员工互为朋友。
输入保证新员工之间的朋友关系形成了一棵树
输出在所有可能的配对方案中，互为朋友的配对数量最多是多少。
输入:
6
1 2 2 3 3
输出 : 2
如样例中，一共有6个新员工，朋友关系有以下五个(1,2),(2,3),(2,4),(3,5),(3,6)。
可以证明无论如何匹配这6个人， 最多只能有两对是互为朋友的，因此输出2。
```

## 去哪儿

### 笔试

算法一：

![image-20220908013930762](https://cdn.fengxianhub.top/resources-master/202209080139862.png)

算法二：

![image-20220908013915142](https://cdn.fengxianhub.top/resources-master/202209080139236.png)

![image-20220908013945773](https://cdn.fengxianhub.top/resources-master/202209080139854.png)

算法三：

![image-20220908013808618](https://cdn.fengxianhub.top/resources-master/202209080138774.png)

![image-20220908013846197](https://cdn.fengxianhub.top/resources-master/202209080138302.png)

## 腾讯云智

### 笔试

单选10  多选10  填空5

算法三道，而且不能用本地IDE

**算法一（10分）**

记不得题目了，好像是给很多字符串，然后匹配啥的，不能用idea完全没有记录

**算法二（15分）**

给定一棵二叉树以及这棵树上的两个节点 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点

https://www.nowcoder.com/questionTerminal/c75deef6d4bf40249c785f240dad4247

**算法三（20分）**

### 一面

一个半小时

1. 自我介绍，上一份实习工作中主要负责那些模块，遇到过什么难点，讲两个？

2. 第一个讲的是使用kafka解耦的案例，具体为用户有很多的事件，例如点赞、登录、进入房间，然后在很多场景下需要拿到这些数据，但是如果写死就耦合了，如果需要横向拓展就需要违反开闭原则，所以我采取的是用kafka进行解耦，下游的消费者只需要实现我自己定义的KafkaEvent接口，当用户事件发生的时候，就会进行回调......

3. 问：具体如何解耦的？  答：通过IOC容器 + 工厂模式 + 策略 + 模板方法进行解耦，然后聊工厂模式有三种，每种都有弊端，spring中的工厂模式通过动态代理 + 反射 + 打标签的方式实现完全解耦，我自己封装了一层kafka的consumer，去监听用户事件，当事件发生的时候再从IOC容器中捞出所有实现KafkaEvent接口的实现类，回调handle方法，这样当我需要横向拓展的时候，只需要继承KafkaEvent接口，就能拿到用户事件，这样完全解耦了上下游的操作，并且可以做到横向拓展

4. 你是怎么在IOC容器中捞实现类的  答：有很多方式，基于spring IOC可以直接注入`List<KafkaEvent>`，就可以直接拿到，但是这种方式可能会拿到未实例完的bean，所以也可以实现`ApplicationAware`接口，里面有一个方法，可以注入IOC容器`ApplicationContext`容器，基于注解的bean都是这个工厂实例化的，通过调用`getBeansOfType`方法就能拿到，基于反射也可以直接拿到JVM中所有实现了KafkaEvent的实现类，再开一个线程池去并发执行里面的handle方法即可

5. 然后我回答另一个难点：还有一个就是涉及到提升QPS的一个难点，我们有很多用户需要每隔一秒拉取一次榜单数据，但是问题就是所有用户在活动的时候都会并发的进行拉取，这就导致接口QPS很高，然后我们通过`合并请求`的方式将QPS提高了20倍

6. 问：提升了这么多，你们怎么做的？答：我们公司内部用kafka比较多，我们借鉴了kafka中`合并请求`的方式，在kafka中并不是发送一条消息就马上发送给broker的，而是会积攒到16k的数据，再发给broker，消费者消费数据的时候，也不会接收到一条数据就马上消费，而是会通过`Poll`机制，拿到500条数据后再进行批量消费，我们借鉴这种思想设计了一套逻辑

7. 问：如何合并请求的？答：首先在springMVC中接口默认作用域为单例，即一个请求过来会由一个独立的线程去处理，处理完后做出响应，我们将作用域改为`request`即每一次网络请求都会创建一个bean去处理，然后我们会将用户事件 + 时间戳 + 用户的响应流对象`HttpServletResponse `封装在一起放入队列中，当队列长度超过500时，统一向Redis中拉取一次Zset排序的数据，这样我们就将500次的并发请求变成串行请求，并且只对Redis做了一次网络IO

8. 问：如果只有一个用户请求，难道就不响应了吗？答：不会的，我们会有一个后台线程去轮训队列里面的元素，当用户等待时间超过了200ms我们也会去做出响应，类比坐车的场景总结一下就是两点：客满了或者时间到了都发车

9. 问：后台线程多久轮训一次，如果有一个用户的请求被错开轮训，可能会轮训两次才做出响应？答：轮训的时间定为50ms，我们的接口其实只需要在1s中内更新即可，时效性并不是特别高，但是并发高，所以我们解决的主要是并发读的问题，对用户来说多几十毫秒是无感知的

10. 你们用的什么队列？答：我们用的是`ArrayBlockingQueue`，但是是线程不安全的，所以我们针对这种读多写少的场景自己写了一个`CopyOnWriteHashMap`，参考`CopyOnWriteArrayList`的思想，继承自`ConcurrentHashMap`，底层通过CAS + synchronized保证线程安全，在每次put的时候都会生成一个快照，在1s中内因为榜单只会修改一次，所以是读多写少，我们通过快照读的方式解决了并发读和并发写之间的冲突

11. 如何解决并发读写的冲突，为什么需要解决？答：因为在`ConcurrentHashMap`进行并发写的时候，其实会堵塞读操作，因为底层通过CAS修改，我们不希望浪费这部分的时间，所以在每次并发写的时候，对上一个版本的数据，也就是上一秒榜单的数据进行快照，当需要读下一秒数据的时候，直接将内存指针指向CAS修改好的内存地址，这样就可以做到并发读写，类似于MVCC中解决并发读写的问题，这里我们也是借鉴了Kafka中的数据结构结合我们具体的业务场景进行实现的

12. 队列大小如何设置？答：通过压测数据也业务并发量进行修改，由算法组的同学具体给出

13. 你这是公司的解决方案叭？还是你想出来的？答：公司的解决方案，但是第一个通过IOC容器和Kafka解耦的是自己想出来的解决方案

14. 回答下SpringBoot自动装配原理？

15. 回答下一个url请求到响应的过程发生那些过程？具体一点

16. 做个算法题

    ```java
    给定一个整数数组 nums
    找到一个具有最大和的连续子数组（子数组最少包含一个元素）返回其最大和
    nums = [-2,1,-3,4,-1,2,1,-5,4]
    ```

    











