## 北京朝夕一面

### 八股文

先从项目开始的，刚开始聊了一下怎么学习java的，学习方式：

>hdfs中存的是什么，小文件存在哪里？

小文件压缩

>redis实现点赞和排行榜怎么做的？具体的数据结构

**zset数据结构**

***SortedSet（zset）***是 ***Redis*** 提供的一个非常特别的数据结构，一方面它等价于 ***Java*** 的数据结构 ***Map<String, Double>***，可以给每一个元素 ***value*** 赋予一个权重 ***score***，另一方面它又类似于 ***TreeSet***，内部的元素会按照权重 ***score*** 进行排序，可以得到每个元素的名次，还可以通过 ***score*** 的范围来获取元素的列表。

***zset*** 底层使用了两个数据结构

- ***hash***，***hash*** 的作用就是关联元素 ***value*** 和权重 ***score***，保障元素 ***value*** 的唯一性，可以通过元素 ***value*** 找到相应的 ***score*** 值
- 跳跃表，跳跃表的目的在于给元素 ***value*** 排序，根据 ***score*** 的范围获取元素列表

>接口幂等性如何保证的，为什么用zookeeper分布式锁保证幂等性，怎么实现的？我回答了一点点，又问这样效率高吗？（面试官觉得这种做法不好）怎么优化? 

这样是将所有的请求串行化了，效率并不高

>zookeeper选举过程，详细说一下



>你刚才讲redis数据是存在内存中的，那么zk的数据存在哪里？磁盘还是内存？我答了内存又问那么zk的数据持久化怎么做的，会不会丢数据？和redis持久化的异同

zk数据是存在内存中的，然后也有类似于redis的内存快照和事物日志的持久化策略

>说一下常用的二叉树，红黑树和AVL树的那个更好？为什么，说一下各自的时间、空间复杂度



>HashMap桶的位置是怎么找到的？为什么用 & 不用 % ，为什么是(length - 1)，为什么要右移32位(一半)



>HashMap添加删除查询的时间复杂度和空间复杂度？你刚才说基于数组的，那么ArrayList的呢？



### 算法题

>一个任意长度的数组，里面装了任意个数字，数字可能是正数、负数和0，就该数组的子数组中积最大的子数组（前提是子数组中数据是连续的，不能跳跃）

动态规划：

```java

```

暴力破解（会超时）：

```java
public int maxAbsoluteSum(int[] nums) {
    int maxNum = 0;
    for (int i = 0; i < nums.length; i++) {
        int cnt = 0;
        for (int j = i; j < nums.length; j++) {
            cnt = cnt + nums[j];
            maxNum = Math.max(maxNum, Math.abs(cnt));
        }
    }
    return maxNum;
}
```

>两张表，用户表和关系表，用户表中有用户id，关系表中有用户的朋友id，查出朋友最多的前十个用户并输出信息

```sql
select * from user where uid in(
	select uid from (
    	select u.uid,count(1) cnt from user u,relationship r where u left join r group by u.uid
    ) order by cnt desc
) limit 10;
```

## 蔚来笔试

### 选择题

考了好多c++，还有操作系统，还有一些Linux的命令，10道单选，5道多选

记得有一个问：cat /proc/cpuinfo |grep "processor"|wc -l | xargs 输出什么？

![image-20220716204445337](https://cdn.fengxianhub.top/resources-master/202207162044461.png)

查看逻辑CPU个数

C++中下面构造函数的执行顺序

```java
class father{
    father(){
        // 1
    }
    _destroy_father(){
        // 4
    }
}
class son extends father{
    son(){
        // 2
    }
    _desory_son(){
        // 3
    }
}
main(){
    new son();
}
```

### 算法题

算法1：

https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&ru=/exam/oj

有一个链表，要求将其中重复的结点去掉，例如

```java
1 -> 2 -> 3 -> 4 -> 5 -> 5 -> 6
```

```java
1 -> 2 -> 3 -> 4 -> 6
```

例如：

```java
1 -> 1 -> 1 -> 4 -> 5 -> 5 -> 6
```

```java
4 -> 6
```

解题思路：

- 首先要构建一个虚拟的头结点，防止前几个结点重复的情况发生
- pre指针应该指向一定不会重复的那个结点，刚开始应该指向我们虚拟的头结点
- last指针是用来移动并判断是否有重复结点的指针

```java
public static ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null) return head;
    // dummy用来标记头结点之前的结点，防止前面元素相同的情况
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    // pre用来标记一定不会重复的元素
    ListNode pre = dummy;
    // last用来标记当前正在移动并且进行比较的指针
    ListNode last = dummy.next;
    while (last != null) {
        if (last.next != null && last.val == last.next.val) {
            // 说明结点相同，跳过所有相同的结点
            while (last.next != null && last.val == last.next.val) {
                last = last.next;
            }
            // 让前一个一定不会重复的指针指向现在的last
            pre.next = last.next;
        } else {
            // 这里表示结点不同，正常往后移动
            pre = pre.next;
        }
        last = last.next;
    }
    return dummy.next;
}
```

算法2（有效的括号升级版）：

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'`，`*` 的字符串 `s` ，判断字符串是否有效，其中`*`表示任意字符，包括空字符

```java
输入：s = "()"
输出：true
输入：s = "(*"
输出：true
输入：s = "*)"
输出：true
输入：s = "*))"
输出：false
输入：s = "*"
输出：true
输入：s = "()*]*]"
输出：true
```

思路：

- 首先遇到左边的括号将其入栈
- 遇到右边的括号出栈一个元素进行比较，不匹配直接false
- 由于 * 表示任意符号，所以要单独处理

```java
public static boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    // 拿到字符数组
    char[] chars = s.toCharArray();
    for (char c : chars) {
        if (c == '(' || c == '{' || c == '[') {
            // 入栈
            stack.push(c);
        } else if (c == ')' || c == '}' || c == ']') {
            // 出栈
            if (stack.isEmpty()) return false;
            char pop = stack.pop();
            // 如果是 * ，可以匹配任意字符，直接跳过
            if (pop == '*') continue;
            if (c == ')' && pop != '(') {
                return false;
            } else if (c == ']' && pop != '[') {
                return false;
            } else if (c == '}' && pop != '{') {
                return false;
            }
        } else {
            // char为 * 的情况，这种要单独进行处理
            // 如果栈为空，将*入栈
            if (stack.isEmpty()) {
                stack.push(c);
            } else {
                // 因为 * 可以匹配任意符号，所以直接出栈一个符号
                stack.pop();
            }
        }
    }
    return stack.isEmpty() || stack.contains('*');
}
```

算法3：有一点点坑的二叉树中序遍历

```java
/**
 * 中序遍历（递归实现）
 */
private void inorderTraversal(Node<E> node) {
    if (node == null) return;
    inorderTraversal(node.left, visitor);
    //业务逻辑，例如输出一句话
    System.out.println(node.val);
    inorderTraversal(node.right, visitor);
}

/**
 * 中序栈实现
 */
private void inorderTraversalByStack(Node<E> node) {
    //只要左结点存在就一直入栈
    while (true) {
        if (node != null) {
            stack.push(node);
            node = node.left;
        } else {
            if (stack.isEmpty()) return;
            node = stack.pop();
            //业务逻辑，例如输出一句话
            System.out.println(node.val);
            node = node.right;
        }
    }
}
```

### 朋友的笔试

```css
算法1：
题目描述
小红可以对一个数进行如下两种操作:将这个数乘以x;或将这个数乘以y操作的次数是没有限制的。
小红想知道，自己最少经过多少次操作以后，可以把a变成b?

输入描述:
四个正整数 x,y,a,b，用空格隔开。2 ≤ x,y ≤ 100 1≤a,b ≤ 109

输出描述:
如果小红无论如何都无法把a变成b，则输出-1.
否则输出小红操作的最少次数。可以证明，如果存在某种操作，那么最少次数一定是固定的。
```



```java
算法2：
题目描述
牛牛对n个城市的旅游情况进行了规划
已知每个城市有两种属性x和y，其中x表示去第号城市的花费表示在第号城市游玩后会得到的开心值，现在生生希望从中挑选出一些城市去游玩，但挑选出的城市必须满足任意两个城市之间花费的绝对值小于k，他想请你帮他计算出在满足上述条件下能得到的最大开心值是多少
    
输入描述:
第一行输入两个正整数n和k.
接下来n行.每行输入两个整数xi和yi分别表示每个城市的两种属性。1<n<100000
1 < k < 1000000000
0 ≤ xi,yi ≤ 1000000000
    
输出描述:
输出一个整数表示答案。
```

```java
算法3：
题目描述
生牛有一个nxm的矩阵，牛生想要找一个子方阵，方阵的大小为lxl且 l>2，这个方阵的价值为其四个角上数字之和。牛生想求价值最大的子方阵，请你告诉牛生这个子方阵的价值。
    
输入描述:
第一行为两个数n，m，表示表示矩阵大小。接下来有n行，每行有m个数 aijo2 ≤ n,m ≤ 10²,1 ≤ aij ≤ 109
    
输出描述:
输出为一行，表示答案。
```

```java
class father{
    father(){
     // 1   
    }
    _destory_father(){
        // 4
    }
}
class son extends father{
    son(){
        // 2
    }
     _destory_father(){
        // 3
    }
}
main{
    new son();
}
```



## 爱的番茄一面

1. hadoop HA结点中多个NameNode的职能（active、standby结点）
2. hadoop HA集群如何做到高可用，集群容灾处理过程？
3. MapReduce过程？ForkJoin过程？
4. 布隆过滤器底层实现原理？布隆过滤器的优点和缺点，这里面试官有一个问题我觉得还比较有意思，**问布隆过滤器如何降低失误率**，我回答手动调整那个失误率的参数，面试官微微一笑🤣，然后就答不会了
5. redis所有数据结构背一下，还有底层实现也背一下（五种基本+三种新增的）
6. redis zset为什么使用跳表而不使用红黑树
7. redis对key做范围查找怎么做？我答了通配符和`keys *`，面试官问用通配符有什么缺点？（这个我是真不知道）
8. redis集群类型 ?（哨兵+分片）, 集群之间数据如何同步，同步过程？（全量同步RDB + 增量同步AOF）
9. ...Redis问了好多，还问了一些命令，就是在黑框框里面输入的那个玩意
10. Mysql了解多少？答：没了解多少。聚集索引非聚集索引区别背一下
11. 联合索引索引失效的场景有哪些？最左原则是什么？如何保证
12. 索引下推是什么你知道吗？**索引建的越多越好吗**？（我回答不是，面试官问我为什么？你讲一下索引如何建比较好？我没答上来😭）
13. 线程同步方式？
14. JDK中的锁有哪些？背一下
15. 线程池的七个参数背一下，阻塞队列背一下，拒绝策略背一下
16. 线程池的核心线程数和最大线程数如何设置？我答了按cpu设置，核心为cpu核心数，最大为cpu核心数两倍；然后还答了一个IO密集型和计算密集型下要提高和降低比例（这里回答反了，面试官当场纠正我🤣，社死）
17. MogoDB有了解过吗？答：没有
18. netty有了解过吗？答：没有😂，然后我回答了一下BIO/NIO的区别和IO多路复用的原理，感觉还是要扯一点的🤣
19. 有玩过实时语音的游戏嘛？答：没有，吃鸡时候找陪玩的时候用过比心❤，其他没用过了。面试官说小伙子不能整天敲代码嘛，游戏还是要玩一些的，我们公司就是做游戏的，如果让你做一款实时语音的游戏你要怎么做？？？？😫我回答用Spark做流式计算，用netty做实时通讯
20. 看你八股文背的还挺熟练的，算法题下一次再给你做叭，你有什么想问我的？问：贵公司的技术栈，答：SpringBoot + MogoDB + 一系列中间件

## 爱的番茄二面

1. 我是公司的技术总监，我先简单介绍一下自己 。。。 你也介绍一下自己
2. 介绍下你的项目？最难的点有哪些
3. 你的项目微服务结构如何设计的？如何做到高可用、高并发
4. 后面基本上都是挖项目
5. ... 项目挖完了之后开始问一些别的
6. 说一个时事新闻，非技术相关的 ？？？🤨🤨🤨我回答了俄乌大战对世界经济的影响
7. 为什么要学大数据？
8. 未来三到五年的职业规划
9. 来了公司时候你想要学习那些新技术。我回答了想用netty写一个高性能的RPC框架，还有就是把大数据其他组件再好好学一下
10. 你有什么想问我的吗？答：没有





















