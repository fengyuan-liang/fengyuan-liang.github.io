# 红黑树

## 1. 红黑树性质

红黑树是一种自平衡的二叉搜索树，以前也叫平衡二叉B树(Symmetric Binary B-tree)

红黑树必须满足以下五条性质：

1. 结点是`RED`或者`BLACK`
2. 根结点是`BLACK`
3. 叶子结点(外部结点，为空结点)都是`BLACK`
4. `RED`结点的子结点都是`BLACK`
   - red结点的parent都是black
     - 从根结点到叶子结点的所有路径上不能有两个连续的red结点

5. 从任意结点到`叶子结点`的所有路径都包含相同数目的`BLACK`结点

![image-20220419180531046](https://cdn.fengxianhub.top/resources-master/202204191805243.png)

>可能刚看完，会感觉完全摸不到头脑，这？这啥玩意！？此时我们的表情可能是这样的，没有关系，好好学一定能学会

![image-20220419181105375](https://cdn.fengxianhub.top/resources-master/202204191811589.png)

在我们分析红黑树之前需要先看一下下面这棵树满不满足红黑树的性质：

![image-20220517152525868](https://cdn.fengxianhub.top/resources-master/202205171525988.png)

>我们重点看性质五，从任意结点到`叶子结点`的所有路径都包含相同数目的`BLACK`结点
>
>这里我们要注意，在红黑树中，叶子结点并不是图中的像`25`、`74`的结点，在红黑树中，叶子结点是虚构出来的结点，且全部为black结点，我们看位置`1`，显然不满足红黑树中的性质五，所以这五条性质我们应该牢记清除！

![image-20220517152804712](https://cdn.fengxianhub.top/resources-master/202205171528816.png)

## 2. 红黑树与B树的等价变换

我们先来看一棵红黑树

![image-20220517153215382](https://cdn.fengxianhub.top/resources-master/202205171532452.png)

接下来我们对这棵红黑树做出一些调整，我们让所有的`红色结点`都上升一层，和其父结点同一层排列

![image-20220517153340973](https://cdn.fengxianhub.top/resources-master/202205171533043.png)

我们仔细看一下，我是不是很眼熟😏，这不就是`B树`吗？而且还是一棵四阶B树

![image-20220517153508552](https://cdn.fengxianhub.top/resources-master/202205171535607.png)

>结论：
>
>- 红黑树 和 4阶B树（2-3-4树）具有等价性
>- `BLACK` 节点与它的 `RED `子节点融合在一起，形成`1个B树节点`
>- 红黑树的 BLACK 节点个数 与 4阶B树的节点总个数相等

其他常见变换有：

![image-20220517154150856](https://cdn.fengxianhub.top/resources-master/202205171541957.png)

## 3. 添加

**在完成红黑树添加编码之前，我们先在原有的代码中添加一些辅助函数**

红黑树具有BST的性质，所以我们让红黑树继承BST，并且我们添加一些辅助函数，便于之后我们的操作

```java
/**
 * @Description: 红黑树
 * @date: 2022/5/17 15:47
 * @author: 梁峰源
 */
public class RedBlackTree<E> extends BinarySearchTree<E> {
    private static final boolean RED = false;
    private static final boolean BLACK = true;

    public RedBlackTree() {
    }

    public RedBlackTree(Comparator<E> comparator) {
        super(comparator);
    }

    /**
     * 红黑树结点
     *
     * @param <E>
     */
    private static class RBNode<E> extends Node<E> {
        boolean color;
        public RBNode(E element, Node<E> parent) {
            super(element, parent);
        }
    }

    @Override
    protected void afterAdd(Node<E> node) {
        super.afterAdd(node);
    }

    @Override
    protected void afterRemove(Node<E> node) {
        super.afterRemove(node);
    }

    /**
     * 将元素染色
     * @param node 带染色的结点
     * @param color 需要染的颜色
     * @return 将染色的结点返回
     */
    private Node<E> color(Node<E> node,boolean color){
        if(node == null) return node;
        ((RBNode<E>)node).color = color;
        return node;
    }
    //染成红色
    private Node<E> red(Node<E> node){
        return color(node,RED);
    }
    //染成黑色
    private Node<E> black(Node<E> node){
        return color(node,BLACK);
    }
    //查看当前结点颜色
    private boolean colorOf(Node<E> node){
        return node == null ? BLACK : ((RBNode<E>)node).color;
    }
    private boolean isBlack(Node<E> node){
        return colorOf(node) == BLACK;
    }
    private boolean isRea(Node<E> node){
        return colorOf(node) == RED;
    }
}
```

在BST的结点中我们需要再添加一些方法

```java
// 返回当前结点的兄弟结点
public Node<E> sibling(){
    if(isLeftChild()){
        return parent.right;
    }
    if(isRightChild()){
        return parent.left;
    }
    //没有兄弟结点
    return null;
}
```

>接下来我们来完成红黑树的添加代码
>
>在红黑树的添加中我们要时刻牢记`B树`的一些基本性质，这样我们才能更好的理解红黑树的性质

我们已经知道了很多`B树`的性质

- B树中，新元素必定是添加到叶子节点中
- 4阶B树所有节点的元素个数 x 都符合 `1 ≤ x ≤ 3`

**建议新添加的节点默认为 RED，这样能够让红黑树的性质尽快满足（性质 1、2、3、5 都满足，性质 4 不一定）**

**如果添加的是根节点，染成 BLACK 即可**

>我们以下面的红黑树为例来看分析添加元素的所有情况

![image-20220517163922449](https://cdn.fengxianhub.top/resources-master/202205171639538.png)

我们在此棵红黑树上添加元素一共会有**12种情况**（结合`B树`的性质我们知道添加的元素一定会到叶子结点上）

![image-20220517164321529](https://cdn.fengxianhub.top/resources-master/202205171643625.png)

其中在四个地方添加结点可以满足红黑树所有的性质（`parent 为 BLACK`），**因此不用做任何额外处理**

![image-20220517164658153](https://cdn.fengxianhub.top/resources-master/202205171646235.png)



>剩下**8种情况**的添加都不能满足红黑树的性质（不满足性质四），所以我们要分别讨论并解决

我们可以看到下面的情况就是`parent为red（double red）`的情况

![image-20220517165201462](https://cdn.fengxianhub.top/resources-master/202205171652556.png)

### 3.1 double red - LL/RR-右旋/左旋

当我们添加的结点出现以下的两种情况的时候（看`52`和`60`两个结点）：

- 我们的做法是将`50`结点染成黑色并且将`46`结点染成红色，并对`46`结点进行左旋
- 其实很有规律，黑色结点的RR两个结点都为红色，我们就需要进行`RR-左旋`，这点和AVL树非常的像，只是红黑树需要将结点重新染色

同理我们对`76`结点采取的方式一样，因为黑结点的`LL`两个结点不满足红黑树性质四，我们就需要完成`LL-右旋`，并将`72`和`76`两个结点重新染色

![image-20220517170525137](https://cdn.fengxianhub.top/resources-master/202205171705219.png)

🎈🎈我们来看一下具体步骤：

判定条件：`uncle 不是 RED`（uncle 为其父结点的兄弟结点）

1. parent 染成 BLACK，grand 染成 RED
2. grand 进行单旋操作（LL：右旋转、RR：左旋转）

完成后的效果图为：

![image-20220517171246737](https://cdn.fengxianhub.top/resources-master/202205171712823.png)

### 3.2 double red - LR/RL-双旋

下面的两种double red产生的情况是因为黑色结点的RL和LR结点都为红色结点而导致异常

我们在AVL树中已经知道需要进行双旋来解决这种情况：

- RL：LL右旋转，RR左旋转（对结点`50`进行右旋转接着对结点`46`进行左旋转）
- LR：RR左旋转，LL右旋转（对结点`72`进行左旋转接着对结点`76`进行右旋转）

![image-20220517171413653](https://cdn.fengxianhub.top/resources-master/202205171714741.png)

调整后的结点为：

![image-20220517172219148](https://cdn.fengxianhub.top/resources-master/202205171722231.png)

🎈🎈我们来看一下具体步骤：

判定条件：`uncle 不是 RED`（uncle 为其父结点的兄弟结点）

1. 自己染成 `BLACK`，grand 染成 `RED`
2. 进行双旋操作
   - LR：parent 左旋转， grand 右旋转
   - RL：parent 右旋转， grand 左旋转

### 3.3 添加 – 修复性质4 –上溢 – LL

![image-20220629125055598](https://cdn.fengxianhub.top/resources-master/202206291255454.png)

上面的红黑树中因为元素`10`，导致四阶B树结点超过三个，这个时候我们会进行上溢，上溢就是跳出中间元素并向上合并，左右分裂

**判定条件：uncle 是 RED**

解决方案：

-  parent、uncle 染成 **BLACK**（将17和33两个结点染成黑色并分裂）
-  grand 向上合并（将结点25当做是新插入的结点并进行修复即可）

这时候结点`25`会上溢，但是又会造成，我们的做法是将结点`25`当做是一个新插入的结点，继续上面的流程，递归处理

- **染成 RED，当做是新添加的节点进行处理（递归操作）**

![image-20220629130421438](https://cdn.fengxianhub.top/resources-master/202206291304532.png)

-  grand 向上合并时，可能继续发生上溢
- 若上溢持续到根节点，只需将根节点染成 BLACK

>可以看出其实出现LL上溢的情况，我们并没有对结点进行旋转，只进行了染色

### 3.4 添加 – 修复性质4 –上溢 – RR

判定条件：uncle 是 RED

- parent、uncle 染成 BLACK
- grand 向上合并

染成 RED，当做是新添加的节点进行处理

![image-20220629200535165](https://cdn.fengxianhub.top/resources-master/202206292005516.png)

解决后：

![image-20220629201140039](https://cdn.fengxianhub.top/resources-master/202206292011174.png)

### 3.5 添加 – 修复性质4 –上溢 – LR

判定条件：uncle 是 RED

- parent、uncle 染成 BLACK
- grand 向上合并

染成 RED，当做是新添加的节点进行处理

![image-20220629200759599](https://cdn.fengxianhub.top/resources-master/202206292007711.png)

解决后：

![image-20220629201111360](https://cdn.fengxianhub.top/resources-master/202206292011489.png)

### 3.6 添加 – 修复性质4 –上溢 – RL

判定条件：uncle 是 RED

- parent、uncle 染成 BLACK
-  grand 向上合并

染成 RED，当做是新添加的节点进行处理

![image-20220629201450876](https://cdn.fengxianhub.top/resources-master/202206292014998.png)

![image-20220629201527944](https://cdn.fengxianhub.top/resources-master/202206292015090.png)

### 3.7 添加总结LL/RR

判定条件：uncle不是RED

- parent染成BLACK，grand染成RED
- grand进行单旋操作

LL右旋转、RR左旋转

![image-20220629202902831](https://cdn.fengxianhub.top/resources-master/202206292029060.png)

### 3.8 添加总结LR/RL

![image-20220629205155204](https://cdn.fengxianhub.top/resources-master/202206292051465.png)

### 3.9 添加所有情况

![image-20220629205453664](https://cdn.fengxianhub.top/resources-master/202206292054963.png)































