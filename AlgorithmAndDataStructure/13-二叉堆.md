# 二叉堆

>我们现在有一个需求，用来存放整数，要求需要提供三个接口
>
>- 添加元数
>- 获取最大值
>- 删除最大值

我们可以用我们熟悉的数据结构去解决这些问题

|                           | 获取最大值 | 删除最大值 | 添加元素 | 描述              |
| ------------------------- | ---------- | ---------- | -------- | ----------------- |
| 动态数组/双向链表         | O(n)       | O(n)       | O(1)     | O(n) 复杂度太高了 |
| （有序）动态数组/双向链表 | O(1)       | O(1)       | O(n)     | 全排序有点浪费    |
| BBST                      | O(logn)    | O(logn)    | O(logn)  | 杀鸡用了牛刀      |
| 堆                        | O(1)       | O(logn)    | O(logn)  | 最优              |

![image-20230518205153842](https://cdn.fengxianhub.top/resources-master/202305182051135.png)

我们思考一下：

- 有序动态数组/双向链表：会全排序，我们其实更需要的是**偏序**
- BBST：每次二分，复杂度`O(logn)`，但是BBST太复杂了

那有没有更优的数据结构呢？当然有，那就是`堆`

## 1. Top K问题&二叉堆

### 1.1 Top K问题

我们将从海量数据中找出前`K`个数据的问题称之为`Top K问题`

例如从100w个整数中找出最大的100个整数。Top K问题的解法之一，就可以使用`堆（heap）`来解决

### 1.2 二叉堆

>二叉堆的逻辑结构就是一棵`完全二叉树`，所以也叫`完全二叉堆`
>
>- 基于完全二叉树的特性，二叉堆的底层可以使用数组实现

![大顶堆](https://cdn.fengxianhub.top/resources-master/202305182104993.png)

使用数组进行实现，相较于`BBST`来说较为简单，例如上面的堆我们用数组进行存储的实现为：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 72   | 68   | 50   | 43   | 38   | 47   | 21   | 14   | 40   | 3    |

观察索引`i`我们可以发现一些规律

- 如果`i = 0`，它就是`根结点`
- 如果`i > 0`，它的父结点编号为`floor(i - 1) / 2`
- 如果`2i + 1 <= n - 1`，它的左子节点编号为`2i + 1`（n为堆元素的个数）
- 如果`2i + 1 > n - 1`，它无左子节点
- 如果`2i + 2 <= n - 1`，它的右子节点编号为`2i + 2`
- 如果`2i + 2 > n - 1`，它无右子节点

例如索引为`5`的结点的父结点的索引就是`(5 - 1) / 2 = 2`，值就是50；例如值为47的结点，序号为5，`2 * 5 + 1 = 11 < 9`，所以没有左子节点；例如值为38的结点，序号为4，`2 * 4 + 1 = 9 <= 9`，所以有左子节点，并且节点为`2 * 4 + 1 = 9`

### 1.3 堆（Heap）

## 2. 二叉堆基本接口

```java
int size(); // 元素的数量
boolean isEmpty(); // 是否为空
void clear(); // 清空
void add(E element); // 添加元素
E get(); // 获得堆顶元素
E remove(); // 删除堆顶元素
E replace(E element); // 删除堆顶元素的同时插入一个新元素
```



















