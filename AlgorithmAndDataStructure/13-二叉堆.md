# 二叉堆

>我们现在有一个需求，用来存放整数，要求需要提供三个接口
>
>- 添加元数
>- 获取最大值
>- 删除最大值

我们可以用我们熟悉的数据结构去解决这些问题

|                           | 获取最大值 | 删除最大值 | 添加元素 | 描述              |
| ------------------------- | ---------- | ---------- | -------- | ----------------- |
| 动态数组/双向链表         | O(n)       | O(n)       | O(1)     | O(n) 复杂度太高了 |
| （有序）动态数组/双向链表 | O(1)       | O(1)       | O(n)     | 全排序有点浪费    |
| BBST                      | O(logn)    | O(logn)    | O(logn)  | 杀鸡用了牛刀      |
| 堆                        | O(1)       | O(logn)    | O(logn)  | 最优              |

![image-20230518205153842](https://cdn.fengxianhub.top/resources-master/202305182051135.png)

我们思考一下：

- 有序动态数组/双向链表：会全排序，我们其实更需要的是**偏序**
- BBST：每次二分，复杂度`O(logn)`，但是BBST太复杂了

那有没有更优的数据结构呢？当然有，那就是`堆`

## 1. Top K问题&二叉堆

### 1.1 Top K问题

我们将从海量数据中找出前`K`个数据的问题称之为`Top K问题`

例如从100w个整数中找出最大的100个整数。Top K问题的解法之一，就可以使用`堆（heap）`来解决

### 1.2 二叉堆

>二叉堆的逻辑结构就是一棵`完全二叉树`，所以也叫`完全二叉堆`
>
>- 基于完全二叉树的特性，二叉堆的底层可以使用数组实现

![大顶堆](https://cdn.fengxianhub.top/resources-master/202305182104993.png)

使用数组进行实现，相较于`BBST`来说较为简单，例如上面的堆我们用数组进行存储的实现为：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 72   | 68   | 50   | 43   | 38   | 47   | 21   | 14   | 40   | 3    |

观察索引`i`我们可以发现一些规律

- 如果`i = 0`，它就是`根结点`
- 如果`i > 0`，它的父结点编号为`floor(i - 1) / 2`
- 如果`2i + 1 <= n - 1`，它的左子节点编号为`2i + 1`（n为堆元素的个数）
- 如果`2i + 1 > n - 1`，它无左子节点
- 如果`2i + 2 <= n - 1`，它的右子节点编号为`2i + 2`
- 如果`2i + 2 > n - 1`，它无右子节点

例如索引为`5`的结点的父结点的索引就是`(5 - 1) / 2 = 2`，值就是50；例如值为47的结点，序号为5，`2 * 5 + 1 = 11 < 9`，所以没有左子节点；例如值为38的结点，序号为4，`2 * 4 + 1 = 9 <= 9`，所以有左子节点，并且节点为`2 * 4 + 1 = 9`

### 1.3 堆（Heap）

## 2. 实现

### 2.1 二叉堆基本接口

```java
int size(); // 元素的数量
boolean isEmpty(); // 是否为空
void clear(); // 清空
void add(E element); // 添加元素
E get(); // 获得堆顶元素
E remove(); // 删除堆顶元素
E replace(E element); // 删除堆顶元素的同时插入一个新元素
```

### 2.2 二叉堆添加逻辑

假设我们现在有一棵二叉堆

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 72   | 68   | 50   | 43   | 38   | 47   | 21   | 14   | 40   | 3    |

现在需要添加一个元素`80`，如果按照数组进行实现，那么我们肯定首先是加上数组的最后面，即这样子：

![image-20230519231051588](https://cdn.fengxianhub.top/resources-master/202305192310845.png)

当时显然这样是不对的，不能满足二叉堆的性质，所以我们需要做的就是`让添加的元素跟父结点进行比较`，因为二叉堆性质就是父结点要比子结点大，即结点`43`要和`14`、`80`，进行比较，如果比子结点小，即交换位置

| 0    | 1    | 2    | `3`  | 4    | 5    | 6    | 7    | 8    | 9    | `10` |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 72   | 68   | 50   | `43` | 38   | 47   | 21   | 14   | 40   | 3    | `80` |

进行交换

| 0    | 1    | 2    | `3`  | 4    | 5    | 6    | 7    | 8    | 9    | `10` |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 72   | 68   | 50   | `80` | 38   | 47   | 21   | 14   | 40   | 3    | `43` |

然后发现还是比父结点大，则继续交换。知道比父结点小或者称为根结点为止

![image-20230519231633692](https://cdn.fengxianhub.top/resources-master/202305192316856.png)

>总结一下：
>
>循环执行以下操作（图中的`80`简称为 node）
>
>- 如果node `>` 父结点，则**与父结点交换位置**
>- 如果node `<=`父结点，或者node成为根结点，则**退出循环**
>
>我们将这个过程称为`上滤（Sift Up）`，时间复杂度为：`O(logn)`

写一下逻辑

```java
/**
 * 让index上的元素进行上滤
 *
 * @param index 元素在数组中的索引
 */
private void siftUp(int index) {
    while (index > 0) {
        // 检查父结点是否小于该元素
        // 父结点编号为`floor(i - 1) / 2`
        int parentIndex = (index - 1) >> 1;
        if (compare(elements[index], elements[parentIndex]) <= 0) {
            return;
        }
        // 交换元素
        E tmp = elements[parentIndex];
        elements[parentIndex] = elements[index];
        elements[index] = tmp;
        index = parentIndex;
    }
}

@SuppressWarnings("unchecked")
private int compare(E e1, E e2) {
    return comparator != null ? comparator.compare(e1, e2) : ((Comparable<E>) e1).compareTo(e2);
}
```

测试一下

```java
@Test
public void TestSiftUp() {
    BinaryHeap<Integer> heap = new BinaryHeap<>();
    int[] arr = new int[]{68, 72, 43, 50, 38};
    for (int i : arr) {
        heap.add(i);
    }
    BinaryTrees.println(heap);
}
// 输出

    ┌─72─┐
    │    │
 ┌─68─┐  43
 │    │
50    38
```

完整代码：

```java
package com.fx.heap;

import com.fx.printer.BinaryTreeInfo;

import java.util.Arrays;
import java.util.Comparator;

/**
 * <p>
 * 默认为最大堆（大顶堆）
 * </p>
 *
 * @author 梁峰源 <fengyuan-liang@foxmail.com>
 * @since 2023/5/18 21:42
 */
public class BinaryHeap<E> implements Heap<E>, BinaryTreeInfo {

    private E[] elements;
    private int size;
    private Comparator<E> comparator;
    private static final int DEFAULT_CAPACITY = 10;

    @SuppressWarnings("unchecked")
    public BinaryHeap(Comparator<E> comparator) {
        this.comparator = comparator;
        this.elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    @SuppressWarnings("unchecked")
    public BinaryHeap() {
        this.elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        Arrays.fill(elements, null);
        return size == 0;
    }

    @Override
    public void clear() {
        size = 0;

    }

    @Override
    public void add(E element) {
        checkElementNotNull(element);
        ensureCapacity(size + 1);
        elements[size++] = element;
        siftUp(size - 1);
    }

    @Override
    public E get() {
        checkEmpty();
        return elements[0];
    }

    @Override
    public E remove() {
        return null;
    }

    @Override
    public E replace(E element) {
        return null;
    }

    /**
     * 让index上的元素进行上滤
     *
     * @param index 元素在数组中的索引
     */
    private void siftUp(int index) {
        while (index > 0) {
            // 检查父结点是否小于该元素
            // 父结点编号为`floor(i - 1) / 2`
            int parentIndex = (index - 1) >> 1;
            if (compare(elements[index], elements[parentIndex]) <= 0) {
                return;
            }
            // 交换元素
            E tmp = elements[parentIndex];
            elements[parentIndex] = elements[index];
            elements[index] = tmp;
            index = parentIndex;
        }
    }

    @SuppressWarnings("unchecked")
    private int compare(E e1, E e2) {
        return comparator != null ? comparator.compare(e1, e2) : ((Comparable<E>) e1).compareTo(e2);
    }

    private void checkEmpty() {
        if (size == 0) {
            throw new IndexOutOfBoundsException("heap is empty");
        }
    }

    private void checkElementNotNull(E element) {
        if (element == null) {
            throw new IllegalArgumentException("there element not null");
        }
    }

    /**
     * 保证集合容量足够
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (capacity < oldCapacity) return;
        // 扩容1.5倍
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        elements = Arrays.copyOf(elements, newCapacity);
    }

    @Override
    public Object root() {
        return 0;
    }

    @Override
    public Object left(Object node) {
        Integer index = (Integer) node;
        int leftIndex = (index << 1) + 1;
        return leftIndex >= size ? null : leftIndex;
    }

    @Override
    public Object right(Object node) {
        Integer index = (Integer) node;
        int rightIndex = (index << 1) + 2;
        return rightIndex >= size ? null : rightIndex;
    }

    @Override
    public Object string(Object node) {
        return elements[(Integer) node];
    }
}

```

### 2.3 删除逻辑

我们发现我们的删除接口是这样的：

```java
E remove(); // 删除堆顶元素
```

我们发现删除时我们并没有传入索引，因为我们只需要删除最大的元素即可。如果我们按照数组的删除逻辑，那就是直接将`index为0`的元素删除，然后其他元素往前移动，这样当然是没有什么问题的，但是这样的时间复杂度就是`O(n)`级别了，不满足我们`log(n)`的要求

那么如果我们将index为0的元素和最后面的元素交换，然后删除最后一个元素的话，这样可以吗？

![image-20230520002316501](https://cdn.fengxianhub.top/resources-master/202305200023631.png)

我们会发现我们这样做的话，`43`会变成根结点，但是不满足堆的性质了

这时候我们需要将根结点和**最大的子结点进行交换**，知道交换不了为止，也就是下面的过程

![image-20230520001545597](https://cdn.fengxianhub.top/resources-master/202305200015869.png)

当交换完成之后，堆的性质将得到维护，我们总结一下过程：

1. 用最后一个结点覆盖根结点
2. 删除最后一个结点
3. 循环以下的步骤（图中的`43`简称为node）

## 附录：源码地址

- <a href="https://github.com/fengyuan-liang/Algorithm/blob/main/10-%E4%BA%8C%E5%8F%89%E5%A0%86/src/com/fx/heap/BinaryHeap.java">堆</a>

