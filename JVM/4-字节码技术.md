# 字节码技术

这里主要学习：

1. 类文件结构 2. 字节码指令 3. 编译期处理 4. 类加载阶段 5. 类加载器 6. 运行期优化

![image-20220602164840888](https://cdn.fengxianhub.top/resources-master/202206021648062.png)

## 1. 类文件结构

一段简单的代码：

```java
public class TestClassLoader {
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
```

我们需要用下面的命令执行（Linux）：

```java
javac -parameters -d . TestClassLoader.java
```

使用下面的命令打印字节码文件

```java
od -t xC TestClassLoader.class
```

结果：

```shell
[root@localhost javascript]# od -t xC TestClassLoader.class 
0000000 ca fe ba be 00 00 00 34 00 1f 0a 00 06 00 11 09
0000020 00 12 00 13 08 00 14 0a 00 15 00 16 07 00 17 07
0000040 00 18 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29
0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e
0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 04 6d 61 69
0000120 6e 01 00 16 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67
0000140 2f 53 74 72 69 6e 67 3b 29 56 01 00 10 4d 65 74
0000160 68 6f 64 50 61 72 61 6d 65 74 65 72 73 01 00 04
0000200 61 72 67 73 01 00 0a 53 6f 75 72 63 65 46 69 6c
0000220 65 01 00 14 54 65 73 74 43 6c 61 73 73 4c 6f 61
0000240 64 65 72 2e 6a 61 76 61 0c 00 07 00 08 07 00 19
0000260 0c 00 1a 00 1b 01 00 0b 68 65 6c 6c 6f 20 77 6f
0000300 72 6c 64 07 00 1c 0c 00 1d 00 1e 01 00 0f 54 65
0000320 73 74 43 6c 61 73 73 4c 6f 61 64 65 72 01 00 10
0000340 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74
0000360 01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73
0000400 74 65 6d 01 00 03 6f 75 74 01 00 15 4c 6a 61 76
0000420 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d
0000440 3b 01 00 13 6a 61 76 61 2f 69 6f 2f 50 72 69 6e
0000460 74 53 74 72 65 61 6d 01 00 07 70 72 69 6e 74 6c
0000500 6e 01 00 15 28 4c 6a 61 76 61 2f 6c 61 6e 67 2f
0000520 53 74 72 69 6e 67 3b 29 56 00 21 00 05 00 06 00
0000540 00 00 00 00 02 00 01 00 07 00 08 00 01 00 09 00
0000560 00 00 1d 00 01 00 01 00 00 00 05 2a b7 00 01 b1
0000600 00 00 00 01 00 0a 00 00 00 06 00 01 00 00 00 01
0000620 00 09 00 0b 00 0c 00 02 00 09 00 00 00 25 00 02
0000640 00 01 00 00 00 09 b2 00 02 12 03 b6 00 04 b1 00
0000660 00 00 01 00 0a 00 00 00 0a 00 02 00 00 00 03 00
0000700 08 00 04 00 0d 00 00 00 05 01 00 0e 00 00 00 01
0000720 00 0f 00 00 00 02 00 10
0000730

```

根据JVM规范，类文件结构为：

```java
ClassFile { // u4表示字节数
    u4 magic; // 魔术字
    u2 minor_version; // 小版本号
    u2 major_version; // 主版本号
    u2 constant_pool_count; // 常量池信息
    cp_info constant_pool[constant_pool_count-1];
    u2 access_flags; // 类的访问权限
    u2 this_class; // 类名信息
    u2 super_class; // 父类信息
    u2 interfaces_count; // 接口数量
    u2 interfaces[interfaces_count]; // 接口信息
    u2 fields_count; // 属性数量
    field_info fields[fields_count];  // 属性信息
    u2 methods_count; // 方法数量
    method_info methods[methods_count]; // 方法信息
    u2 attributes_count; // 属性信息
    attribute_info attributes[attributes_count];
}
```

### 1.1 魔数

0~3 字节，表示它是否是【class】类型的文件

0000000 ***ca fe ba be*** 00 00 00 34 00 23 0a 00 06 00 15 09

### 1.2 版本

4~7 字节，表示类的版本16进制 00 34（十进制：52） 表示是 Java 8

0000000 ca fe ba be ***00 00 00 34*** 00 23 0a 00 06 00 15 09

### 1.3 常量池

| Constant Type               | Value |
| --------------------------- | ----- |
| CONSTANT_Class              | 7     |
| CONSTANT_Fieldref           | 9     |
| CONSTANT_Methodref          | 10    |
| CONSTANT_InterfaceMethodref | 11    |
| CONSTANT_String             | 8     |
| CONSTANT_Integer            | 3     |
| CONSTANT_Float              | 4     |
| CONSTANT_Long               | 5     |
| CONSTANT_Double             | 6     |
| CONSTANT_NameAndType        | 12    |
| CONSTANT_Utf8               | 1     |
| CONSTANT_MethodHandle       | 15    |
| CONSTANT_MethodType         | 16    |
| CONSTANT_InvokeDynamic      | 18    |

8~9 字节，表示常量池长度，00 23 （35） 表示常量池有 #1~#34项，注意 #0 项不计入，也没有值

0000000 ca fe ba be 00 00 00 34 <em>00 23 </em>0a 00 06 00 15 09



第#1项 0a 表示一个 Method 信息，00 06 和 00 15（21） 表示它引用了常量池中 #6 和 #21 项来获得 这个方法的【所属类】和【方法名】

0000000 ca fe ba be 00 00 00 34 00 23 <em>0a 00 06 00 15</em> 09



第#2项 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 # 23 项 来获得这个成员变量的【所属类】和【成员变量名】

0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <em>09</em> 

0000020 <em>00 16 00 17</em> 08 00 18 0a 00 19 00 1a 07 00 1b 07



第#3项 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项 

0000020 00 16 00 17 <em>08 00 18</em> 0a 00 19 00 1a 07 00 1b 07



第#4项 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26 项来获得这个方法的【所属类】和【方法名】 

0000020 00 16 00 17 08 00 18 <em>0a 00 19 00 1a</em> 07 00 1b 07



第#5项 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <em>07 00 1b</em> 07



第#6项 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项

0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <em>07</em>

0000040 <em>00 1c</em> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29



第#7项 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是【 `<init>` 】

0000040 00 1c <em>01 00 06 3c 69 6e 69 74 3e</em> 01 00 03 28 29



第#8项 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是【()V】其实就是表示无参、无返回值

0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <em>01 00 03 28 29</em>

0000060 <em>56</em> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e



第#9项 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是【Code】

 0000060 56 <em>01 00 04 43 6f 64 65</em> 01 00 0f 4c 69 6e 65 4e



第#10项 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是【LineNumberTable】

0000060 56 01 00 04 43 6f 64 65 <em>01 00 0f 4c 69 6e 65 4e </em>

0000100 <em>75 6d 62 65 72 54 61 62 6c 65</em> 01 00 12 4c 6f 63



第#11项 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是【LocalVariableTable】

0000100 75 6d 62 65 72 54 61 62 6c 65 <em>01 00 12 4c 6f 63 </em>

0000120 <em>61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65</em> 01



第#12项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【this】

0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 

0000140 <em>00 04 74 68 69 73</em> 01 00 1d 4c 63 6e 2f 69 74 63



第#13项 01 表示一个 utf8 串，00 1d（29） 表示长度，是【Lcn/itcast/jvm/t5/HelloWorld;】

0000140 00 04 74 68 69 73 <em>01 00 1d 4c 63 6e 2f 69 74 63</em>

0000160 <em>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</em>

0000200 <em>57 6f 72 6c 64 3b</em> 01 00 04 6d 61 69 6e 01 00 16



第#14项 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是【main】

0000200 57 6f 72 6c 64 3b <em>01 00 04 6d 61 69 6e</em> 01 00 16



第#15项 01 表示一个 utf8 串，00 16（22） 表示长度，是【([Ljava/lang/String;)V】其实就是参数为 字符串数组，无返回值

0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e <em>01 00 16 </em>

0000220 <em>28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </em>

0000240 <em>69 6e 67 3b 29 56</em> 01 00 04 61 72 67 73 01 00 13



第#16项 01 表示一个 utf8 串，00 04 表示长度，是【args】

0000240 69 6e 67 3b 29 56 <em>01 00 04 61 72 67 73</em> 01 00 13



第#17项 01 表示一个 utf8 串，00 13（19） 表示长度，是【[Ljava/lang/String;】

0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 <em>01 00 13 </em>

0000260 <em>5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </em>

0000300 <em>6e 67 3b</em> 01 00 10 4d 65 74 68 6f 64 50 61 72 61



第#18项 01 表示一个 utf8 串，00 10（16） 表示长度，是【MethodParameters】

0000300 6e 67 3b <em>01 00 10 4d 65 74 68 6f 64 50 61 72 61 </em>

0000320 <em>6d 65 74 65 72 73</em> 01 00 0a 53 6f 75 72 63 65 46



第#19项 01 表示一个 utf8 串，00 0a（10） 表示长度，是【SourceFile】

0000320 6d 65 74 65 72 73 <em>01 00 0a 53 6f 75 72 63 65 46 </em>

0000340 <em>69 6c 65</em> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64



第#20项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【HelloWorld.java】

0000340 69 6c 65 <em>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 </em>

0000360 <em>2e 6a 61 76 61</em> 0c 00 07 00 08 07 00 1d 0c 00 1e



第#21项 0c 表示一个 【名+类型】，00 07 00 08 引用了常量池中 #7 #8 两项

0000360 2e 6a 61 76 61 <em>0c 00 07 00 08</em> 07 00 1d 0c 00 1e



第#22项 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项

0000360 2e 6a 61 76 61 0c 00 07 00 08 <em>07 00 1d</em> 0c 00 1e



第#23项 0c 表示一个 【名+类型】，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项

0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <em>0c 00 1e </em>

0000400 <em>00 1f</em> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64



第#24项 01 表示一个 utf8 串，00 0f（15） 表示长度，是【hello world】 

0000400 00 1f <em>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</em>



第#25项 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项

0000420 <em>07 00 20</em> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74



第#26项 0c 表示一个 【名+类型】，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项

0000420 07 00 20 <em>0c 00 21 00 22</em> 01 00 1b 63 6e 2f 69 74



第#27项 01 表示一个 utf8 串，00 1b（27） 表示长度，是【cn/itcast/jvm/t5/HelloWorld】

0000420 07 00 20 0c 00 21 00 22 <em>01 00 1b 63 6e 2f 69 74 </em>

0000440 <em>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</em> 

0000460 <em>6f 57 6f 72 6c 64</em> 01 00 10 6a 61 76 61 2f 6c 61



第#28项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/Object】

0000460 6f 57 6f 72 6c 64 <em>01 00 10 6a 61 76 61 2f 6c 61 </em>

0000500 <em>6e 67 2f 4f 62 6a 65 63 74</em> 01 00 10 6a 61 76 61



第#29项 01 表示一个 utf8 串，00 10（16） 表示长度，是【java/lang/System】

0000500 6e 67 2f 4f 62 6a 65 63 74 <em>01 00 10 6a 61 76 61 </em>

0000520 <em>2f 6c 61 6e 67 2f 53 79 73 74 65 6d</em> 01 00 03 6f



第#30项 01 表示一个 utf8 串，00 03 表示长度，是【out】

0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d <em>01 00 03 6f </em>

0000540 <em>75 74</em> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72



第#31项 01 表示一个 utf8 串，00 15（21） 表示长度，是【Ljava/io/PrintStream;】

0000540 75 74 <em>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </em>

0000560 <em>69 6e 74 53 74 72 65 61 6d 3b</em> 01 00 13 6a 61 76



第#32项 01 表示一个 utf8 串，00 13（19） 表示长度，是【java/io/PrintStream】

0000560 69 6e 74 53 74 72 65 61 6d 3b <em>01 00 13 6a 61 76 </em>

0000600 <em>61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</em>



第#33项 01 表示一个 utf8 串，00 07 表示长度，是【println】 

0000620 <em>01 00 07 70 72 69 6e 74 6c 6e</em> 01 00 15 28 4c 6a



第#34项 01 表示一个 utf8 串，00 15（21） 表示长度，是【(Ljava/lang/String;)V】

0000620 01 00 07 70 72 69 6e 74 6c 6e <em>01 00 15 28 4c 6a </em>

0000640 <em>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</em> 

0000660 <em>29 56</em> 00 21 00 05 00 06 00 00 00 00 00 02 00 01

## 2. 字节码指令

### 2.1 入门

### 2.2 javap工具

自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件

```java
javap -v HelloWorld.class //-v打印详细信息
```

```java
[root@localhost javascript]# javap -v TestClassLoader.class 
Classfile /root/fengyuanDir/javascript/TestClassLoader.class
  Last modified Jun 2, 2022; size 472 bytes
  MD5 checksum 11b3be535f6465a2a971c9d6fd448c5c
  Compiled from "TestClassLoader.java"
public class TestClassLoader
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#17         // java/lang/Object."<init>":()V
   #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #20            // hello world
   #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #23            // TestClassLoader
   #6 = Class              #24            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               MethodParameters
  #14 = Utf8               args
  #15 = Utf8               SourceFile
  #16 = Utf8               TestClassLoader.java
  #17 = NameAndType        #7:#8          // "<init>":()V
  #18 = Class              #25            // java/lang/System
  #19 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;
  #20 = Utf8               hello world
  #21 = Class              #28            // java/io/PrintStream
  #22 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V
  #23 = Utf8               TestClassLoader
  #24 = Utf8               java/lang/Object
  #25 = Utf8               java/lang/System
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = Utf8               java/io/PrintStream
  #29 = Utf8               println
  #30 = Utf8               (Ljava/lang/String;)V
{
  public TestClassLoader();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String hello world
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 3: 0
        line 4: 8
    MethodParameters:
      Name                           Flags
      args
}
SourceFile: "TestClassLoader.java"
```

### 2.3 图解方法执行流程

原始的java代码：

```java
public class TestByteCode {
    public static void main(String[] args) {
        int a = 10;
        int b = Short.MAX_VALUE + 1; //一旦超出了short的容量就会存储在常量池中
        int c = a + b;
        System.out.println(c);
    }
}
```

编译后的字节码：

```java
Classfile /E:/workspacesJ2SE_idea/JavaVirtualMachine/target/classes/com/fx/cla
ssLoader/TestByteCode.class
  Last modified 2022-6-2; size 636 bytes
  MD5 checksum d8dc32170dc1cafe0b1a118eac2d5693
  Compiled from "TestByteCode.java"
public class com.fx.classLoader.TestByteCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #7.#25         // java/lang/Object."<init>":()V
   #2 = Class              #26            // java/lang/Short
   #3 = Integer            32768
   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/Pri
ntStream;
   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V
   #6 = Class              #31            // com/fx/classLoader/TestByteCode
   #7 = Class              #32            // java/lang/Object
   #8 = Utf8               <init>
   #9 = Utf8               ()V
  #10 = Utf8               Code
  #11 = Utf8               LineNumberTable
  #12 = Utf8               LocalVariableTable
  #13 = Utf8               this
  #14 = Utf8               Lcom/fx/classLoader/TestByteCode;
  #15 = Utf8               main
  #16 = Utf8               ([Ljava/lang/String;)V
  #17 = Utf8               args
  #18 = Utf8               [Ljava/lang/String;
  #19 = Utf8               a
  #20 = Utf8               I
  #21 = Utf8               b
  #22 = Utf8               c
  #23 = Utf8               SourceFile
  #24 = Utf8               TestByteCode.java
  #25 = NameAndType        #8:#9          // "<init>":()V
  #26 = Utf8               java/lang/Short
  #27 = Class              #33            // java/lang/System
  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;
  #29 = Class              #36            // java/io/PrintStream
  #30 = NameAndType        #37:#38        // println:(I)V
  #31 = Utf8               com/fx/classLoader/TestByteCode
  #32 = Utf8               java/lang/Object
  #33 = Utf8               java/lang/System
  #34 = Utf8               out
  #35 = Utf8               Ljava/io/PrintStream;
  #36 = Utf8               java/io/PrintStream
  #37 = Utf8               println
  #38 = Utf8               (I)V
{
  public com.fx.classLoader.TestByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<ini
t>":()V
         4: return
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/fx/classLoader/TestByteCode;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: ldc           #3                  // int 32768
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: getstatic     #4                  // Field java/lang/System.out:Lj
ava/io/PrintStream;
        13: iload_3
        14: invokevirtual #5                  // Method java/io/PrintStream.pr
intln:(I)V
        17: return
      LineNumberTable:
        line 10: 0
        line 11: 3
        line 12: 6
        line 13: 10
        line 14: 17
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      18     0  args   [Ljava/lang/String;
            3      15     1     a   I
            6      12     2     b   I
           10       8     3     c   I
}
SourceFile: "TestByteCode.java"

```

#### 2.3.1 常量池载入运行时常量池

![image-20220602185624658](https://cdn.fengxianhub.top/resources-master/202206021856005.png)

#### 2.3.2 方法字节码载入方法区

![image-20220602185827214](https://cdn.fengxianhub.top/resources-master/202206021858315.png)

#### 2.3.3 main线程开始运行，分配栈帧内存

（stack=2，locals=4）

![image-20220602185909177](https://cdn.fengxianhub.top/resources-master/202206021859281.png)

#### 2.3.4 执行引擎开始执行字节码

bipush 10

- 将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 
- sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） 
- ldc 将一个 int 压入操作数栈 
- ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节） 
- 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池

![image-20220602190255637](https://cdn.fengxianhub.top/resources-master/202206021902716.png)

istore_1

- 将操作数栈顶数据弹出，存入局部变量表的 slot 1

![image-20220602190319218](https://cdn.fengxianhub.top/resources-master/202206021903309.png)

ldc #3

- 从常量池加载 #3 数据到操作数栈
- 注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算 好的

![image-20220602190442020](https://cdn.fengxianhub.top/resources-master/202206021904133.png)



istore_2

![image-20220602190706612](https://cdn.fengxianhub.top/resources-master/202206021907721.png)

iload_1

![image-20220602190719418](https://cdn.fengxianhub.top/resources-master/202206021907515.png)

iload_2

![image-20220602190738629](https://cdn.fengxianhub.top/resources-master/202206021907720.png)

iadd

![image-20220602190755955](https://cdn.fengxianhub.top/resources-master/202206021907050.png)

istore_3

![image-20220602190808633](https://cdn.fengxianhub.top/resources-master/202206021908746.png)

getstatic #4

![image-20220602190822643](https://cdn.fengxianhub.top/resources-master/202206021908748.png)

![image-20220602190829544](https://cdn.fengxianhub.top/resources-master/202206021908621.png)

iload_3

![image-20220602190841413](https://cdn.fengxianhub.top/resources-master/202206021908517.png)

invokevirtual #5

- 找到常量池 #5 项 
- 定位到方法区 java/io/PrintStream.println:(I)V 方法 
- 生成新的栈帧（分配 locals、stack等） 
- 传递参数，执行新栈帧中的字节码

![image-20220602190915169](https://cdn.fengxianhub.top/resources-master/202206021909256.png)

- 执行完毕，弹出栈帧 
- 清除 main 操作数栈内容

![image-20220602190936458](https://cdn.fengxianhub.top/resources-master/202206021909544.png)

return

- 完成 main 方法调用，弹出 main 栈帧 
- 程序结束

### 2.4 分析i++

我们分析下面的代码：

```java
public class TestByteCode {
    public static void main(String[] args) {
        int a = 10;
        int b = a++ + ++a + a--;
        System.out.println(a);
        System.out.println(b);
    }
}
```

我们可以很快得出答案是 11 34，现在我们从字节码的角度分析一下

对应字节码为：

```java
Classfile /E:/workspacesJ2SE_idea/JavaVirtualMachine/target/classes/com/fx/cla
ssLoader/TestByteCode.class
  Last modified 2022-6-2; size 611 bytes
  MD5 checksum 7c46f961f2a081fae72c22c2a6f62b41
  Compiled from "TestByteCode.java"
public class com.fx.classLoader.TestByteCode
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #5.#22         // java/lang/Object."<init>":()V
   #2 = Fieldref           #23.#24        // java/lang/System.out:Ljava/io/Pri
ntStream;
   #3 = Methodref          #25.#26        // java/io/PrintStream.println:(I)V
   #4 = Class              #27            // com/fx/classLoader/TestByteCode
   #5 = Class              #28            // java/lang/Object
   #6 = Utf8               <init>
   #7 = Utf8               ()V
   #8 = Utf8               Code
   #9 = Utf8               LineNumberTable
  #10 = Utf8               LocalVariableTable
  #11 = Utf8               this
  #12 = Utf8               Lcom/fx/classLoader/TestByteCode;
  #13 = Utf8               main
  #14 = Utf8               ([Ljava/lang/String;)V
  #15 = Utf8               args
  #16 = Utf8               [Ljava/lang/String;
  #17 = Utf8               a
  #18 = Utf8               I
  #19 = Utf8               b
  #20 = Utf8               SourceFile
  #21 = Utf8               TestByteCode.java
  #22 = NameAndType        #6:#7          // "<init>":()V
  #23 = Class              #29            // java/lang/System
  #24 = NameAndType        #30:#31        // out:Ljava/io/PrintStream;
  #25 = Class              #32            // java/io/PrintStream
  #26 = NameAndType        #33:#34        // println:(I)V
  #27 = Utf8               com/fx/classLoader/TestByteCode
  #28 = Utf8               java/lang/Object
  #29 = Utf8               java/lang/System
  #30 = Utf8               out
  #31 = Utf8               Ljava/io/PrintStream;
  #32 = Utf8               java/io/PrintStream
  #33 = Utf8               println
  #34 = Utf8               (I)V
{
  public com.fx.classLoader.TestByteCode();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<ini
t>":()V
         4: return
      LineNumberTable:
        line 8: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/fx/classLoader/TestByteCode;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: bipush        10
         2: istore_1
         3: iload_1
         4: iinc          1, 1
         7: iinc          1, 1
        10: iload_1
        11: iadd
        12: iload_1
        13: iinc          1, -1
        16: iadd
        17: istore_2
        18: getstatic     #2                  // Field java/lang/System.out:Lj
ava/io/PrintStream;
        21: iload_1
        22: invokevirtual #3                  // Method java/io/PrintStream.pr
intln:(I)V
        25: getstatic     #2                  // Field java/lang/System.out:Lj
ava/io/PrintStream;
        28: iload_2
        29: invokevirtual #3                  // Method java/io/PrintStream.pr
intln:(I)V
        32: return
      LineNumberTable:
        line 10: 0
        line 11: 3
        line 12: 18
        line 13: 25
        line 14: 32
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      33     0  args   [Ljava/lang/String;
            3      30     1     a   I
           18      15     2     b   I
}
SourceFile: "TestByteCode.java"
```

分析：

- 注意 iinc 指令是直接在局部变量 slot 上进行运算
- a++ 和 ++a 的区别是先执行 iload 还是 先执行 iinc

![image-20220602191704155](https://cdn.fengxianhub.top/resources-master/202206021917332.png)



![image-20220602191727469](https://cdn.fengxianhub.top/resources-master/202206021917571.png)



![image-20220602191912521](https://cdn.fengxianhub.top/resources-master/202206021919613.png)

![image-20220602191919146](https://cdn.fengxianhub.top/resources-master/202206021919245.png)

![image-20220602191924693](https://cdn.fengxianhub.top/resources-master/202206021919791.png)

![image-20220602191930740](https://cdn.fengxianhub.top/resources-master/202206021919874.png)

![image-20220602191936968](https://cdn.fengxianhub.top/resources-master/202206021919066.png)

![image-20220602191943506](https://cdn.fengxianhub.top/resources-master/202206021919624.png)

![image-20220602191949482](https://cdn.fengxianhub.top/resources-master/202206021919573.png)

![image-20220602191957320](https://cdn.fengxianhub.top/resources-master/202206021919447.png)

### 2.5 条件判断指令

![image-20220602192249707](https://cdn.fengxianhub.top/resources-master/202206021922830.png)

几点说明：

- byte，short，char 都会按 int 比较，因为操作数栈都是 4 字节 
- goto 用来进行跳转到指定行号的字节码

源码：

```java
public class Demo3_3 {
    public static void main(String[] args) {
        int a = 0;
        if(a == 0) {
            a = 10;
        } else {
            a = 20;
        }
    }
}
```

字节码：

```java
0: iconst_0
1: istore_1
2: iload_1
3: ifne 		12
6: bipush 		10
8: istore_1
9: goto 		15
12: bipush 		20
14: istore_1
15: return
```

以上比较指令中没有 long，float，double 的比较，那么它们要比较怎 么办？

参考 https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.lcmp

### 2.6 循环控制指令

其实循环控制还是前面介绍的那些指令，例如 while 循环：

```java
public class Demo3_4 {
    public static void main(String[] args) {
        int a = 0;
        while (a < 10) {
            a++;
        }
    }
}
```

字节码：

```java
0: iconst_0
1: istore_1
2: iload_1
3: bipush 		10
5: if_icmpge 	14
8: iinc 1, 		1
11: goto 		2
14: return
```

再比如 do while 循环：

```java
public class Demo3_5 {
    public static void main(String[] args) {
        int a = 0;
        do {
            a++;
        } while (a < 10);
    }
}
```

字节码是：

```java
0: iconst_0
 1: istore_1
 2: iinc 1, 	1
 5: iload_1
 6: bipush 		10
 8: if_icmplt 	2
11: return
```

最后再看看 for 循环：

```java
public class Demo3_6 {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
        }
    }
}
```

```java
iconst_0
1: istore_1
2: iload_1
3: bipush 		10
5: if_icmpge 	14
8: iinc 1, 		1
11: goto 		2
14: return
```

>比较 while 和 for 的字节码，你发现它们是一模一样的，殊途也能同归😙

### 2.7 练习 - 判断结果

请从字节码角度分析，下列代码运行的结果：

```java
public class Demo3_6_1 {
    public static void main(String[] args) {
        int i = 0;
        int x = 0;
        while (i < 10) {
            x = x++;
            i++;
        }
        System.out.println(x); // 结果是 0
    }
}
```

### 2.8 构造方法

`<cinit>()V`  (整个类的构造方法)

```java
public class Demo3_8_1 {
    static int i = 10;
    static {
        i = 20;
    }
    static {
        i = 30;
    }
}
```

编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法`<cinit>()V`

```java
0: bipush 10
2: putstatic #2 // Field i:I
5: bipush 20
7: putstatic #2 // Field i:I
10: bipush 30
12: putstatic #2 // Field i:I
15: return
```

`<cinit>()V` 方法会在类加载的初始化阶段被调用！



`<init>()V`

先来看一到面试题：

```java
public class Demo3_8_2 {
    private String a = "s1";

    {
        b = 20;
    }

    private int b = 10;

    {
        a = "s2";
    }

    public Demo3_8_2(String a, int b) {
        this.a = a;
        this.b = b;
    }
    public static void main(String[] args) {
        Demo3_8_2 d = new Demo3_8_2("s3", 30);
        System.out.println(d.a);
        System.out.println(d.b);
    }
}
```

>编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后！

```java
Classfile /E:/workspacesJ2SE_idea/JavaVirtualMachine/target/classes/com/fx/classLoader/Demo3_8_2.class
  Last modified 2022-6-2; size 824 bytes
  MD5 checksum 07221e940ad9f0edb6f8c24e33c12a6c
  Compiled from "Demo3_8_2.java"
public class com.fx.classLoader.Demo3_8_2
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #12.#31        // java/lang/Object."<init>":()V
   #2 = String             #32            // s1
   #3 = Fieldref           #6.#33         // com/fx/classLoader/Demo3_8_2.a:Ljava/lang/String;
   #4 = Fieldref           #6.#34         // com/fx/classLoader/Demo3_8_2.b:I
   #5 = String             #35            // s2
   #6 = Class              #36            // com/fx/classLoader/Demo3_8_2
   #7 = String             #37            // s3
   #8 = Methodref          #6.#38         // com/fx/classLoader/Demo3_8_2."<init>":(Ljava/lang/String;I)V
   #9 = Fieldref           #39.#40        // java/lang/System.out:Ljava/io/PrintStream;
  #10 = Methodref          #41.#42        // java/io/PrintStream.println:(Ljava/lang/String;)V
  #11 = Methodref          #41.#43        // java/io/PrintStream.println:(I)V
  #12 = Class              #44            // java/lang/Object
  #13 = Utf8               a
  #14 = Utf8               Ljava/lang/String;
  #15 = Utf8               b
  #16 = Utf8               I
  #17 = Utf8               <init>
  #18 = Utf8               (Ljava/lang/String;I)V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               LocalVariableTable
  #22 = Utf8               this
  #23 = Utf8               Lcom/fx/classLoader/Demo3_8_2;
  #24 = Utf8               main
  #25 = Utf8               ([Ljava/lang/String;)V
  #26 = Utf8               args
  #27 = Utf8               [Ljava/lang/String;
  #28 = Utf8               d
  #29 = Utf8               SourceFile
  #30 = Utf8               Demo3_8_2.java
  #31 = NameAndType        #17:#45        // "<init>":()V
  #32 = Utf8               s1
  #33 = NameAndType        #13:#14        // a:Ljava/lang/String;
  #34 = NameAndType        #15:#16        // b:I
  #35 = Utf8               s2
  #36 = Utf8               com/fx/classLoader/Demo3_8_2
  #37 = Utf8               s3
  #38 = NameAndType        #17:#18        // "<init>":(Ljava/lang/String;I)V
  #39 = Class              #46            // java/lang/System
  #40 = NameAndType        #47:#48        // out:Ljava/io/PrintStream;
  #41 = Class              #49            // java/io/PrintStream
  #42 = NameAndType        #50:#51        // println:(Ljava/lang/String;)V
  #43 = NameAndType        #50:#52        // println:(I)V
  #44 = Utf8               java/lang/Object
  #45 = Utf8               ()V
  #46 = Utf8               java/lang/System
  #47 = Utf8               out
  #48 = Utf8               Ljava/io/PrintStream;
  #49 = Utf8               java/io/PrintStream
  #50 = Utf8               println
  #51 = Utf8               (Ljava/lang/String;)V
  #52 = Utf8               (I)V
{
  public com.fx.classLoader.Demo3_8_2(java.lang.String, int);
    descriptor: (Ljava/lang/String;I)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=3
         0: aload_0     
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: ldc           #2                  // <- "s1"
         7: putfield      #3                  // -> this.a a:Ljava/lang/String;
        10: aload_0
        11: bipush        20   				  // <- 20
        13: putfield      #4                  // -> this.b
        16: aload_0
        17: bipush        10			      // <- 10
        19: putfield      #4                  // -> this.b
        22: aload_0
        23: ldc           #5                  // String s2
        25: putfield      #3                  // -> this.b a:Ljava/lang/String;
        28: aload_0							  // --------------------
        29: aload_1							  // <- slot 1(a) "s3"  
        30: putfield      #3                  // -> this.a   a:Ljava/lang/String;                                                
        33: aload_0
        34: iload_2							  // <- slot 2(b) 30
        35: putfield      #4                  // -> this.b -----------
        38: return
      LineNumberTable:
        line 21: 0
        line 9: 4
        line 12: 10
        line 15: 16
        line 18: 22
        line 22: 28
        line 23: 33
        line 24: 38
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      39     0  this   Lcom/fx/classLoader/Demo3_8_2;
            0      39     1     a   Ljava/lang/String;
            0      39     2     b   I

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=4, locals=2, args_size=1
         0: new           #6                  // class com/fx/classLoader/Demo3_8_2
         3: dup
         4: ldc           #7                  // String s3
         6: bipush        30
         8: invokespecial #8                  // Method "<init>":(Ljava/lang/String;I)V
        11: astore_1
        12: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
        15: aload_1
        16: getfield      #3                  // Field a:Ljava/lang/String;
        19: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        22: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;
        25: aload_1
        26: getfield      #4                  // Field b:I
        29: invokevirtual #11                 // Method java/io/PrintStream.println:(I)V
        32: return
      LineNumberTable:
        line 26: 0
        line 27: 12
        line 28: 22
        line 29: 32
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      33     0  args   [Ljava/lang/String;
           12      21     1     d   Lcom/fx/classLoader/Demo3_8_2;
}
SourceFile: "Demo3_8_2.java"

```

### 2.9 方法调用

看一下几种不同的方法调用对应的字节码指令

```java
public class Demo3_9 {
    public Demo3_9() { }
    private void test1() { }
    private final void test2() { }
    public void test3() { }
    public static void test4() { }
    public static void main(String[] args) {
        Demo3_9 d = new Demo3_9();
        d.test1();
        d.test2();
        d.test3();
        d.test4();
        Demo3_9.test4();
    }
}
```

字节码：

```java
0: new #2 // class cn/itcast/jvm/t3/bytecode/Demo3_9
3: dup
4: invokespecial #3 // Method "<init>":()V
7: astore_1
8: aload_1
9: invokespecial #4 // Method test1:()V
12: aload_1
13: invokespecial #5 // Method test2:()V
16: aload_1
17: invokevirtual #6 // Method test3:()V
20: aload_1
21: pop
22: invokestatic #7 // Method test4:()V
25: invokestatic #7 // Method test4:()V
28: return

```

- new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈
- dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配 合 invokespecial 调用该对象的构造方法 "`<cinit>()V`":()V （会消耗掉栈顶一个引用），另一个要配合 astore_1 赋值给局部变量
- 最终方法（final），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定
- 普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态
- 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】
- 比较有意思的是 d.test4(); 是通过【对象引用】调用一个静态方法，可以看到在调用 invokestatic 之前执行了 pop 指令，把【对象引用】从操作数栈弹掉了
- 还有一个执行 invokespecial 的情况是通过 super 调用父类方法

### 2.10 多态的原理

演示代码：

```java
**
 * 演示多态原理，注意加上下面的 JVM 参数，禁用指针压缩
 * -XX:-UseCompressedOops -XX:-UseCompressedClassPointers
 */
public class Demo3_10 {
    public static void test(Animal animal) {
        animal.eat();
        System.out.println(animal.toString());
    }
    public static void main(String[] args) throws IOException {
        test(new Cat());
        test(new Dog());
        System.in.read();
    }
}
abstract class Animal {
    public abstract void eat();
    @Override
    public String toString() {
        return "我是" + this.getClass().getSimpleName();
    }
}
class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("啃骨头");
    }
}
class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("吃鱼");
    }
}
```

**运行HSDB工具**

执行

```java
java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB
```

进入图形化界面attach并输入进程 id（可以通过jps指令获取）

![image-20220602223234534](https://cdn.fengxianhub.top/resources-master/202206022232657.png)



![image-20220602223155760](https://cdn.fengxianhub.top/resources-master/202206022231082.png)

然后我就可以查找我们想要的对象了

![image-20220602223716082](https://cdn.fengxianhub.top/resources-master/202206022237236.png)

这里的命令类似有sql，例如我想查找Dog，这里我需要带上包名，并且可以给类起别称

```java
select d from com.fx.classLoader.Dog d
```

![image-20220602224102081](https://cdn.fengxianhub.top/resources-master/202206022241199.png)

这样就可以查询出对象在内存中的地址，因为我们Dog对象只有一个，所以这个地址一定是我们想要的那个地址，我们点进去就可以看到这个对象的信息

<img src="https://cdn.fengxianhub.top/resources-master/202206022244715.png" alt="image-20220602224420586" style="zoom:80%;" />

接着我们在window中打开一个命令行窗口，输入这个对象的地址我们就可以看到这个对象指针的地址，是下面的那个

<img src="https://cdn.fengxianhub.top/resources-master/202206022246530.png" alt="image-20220602224622415" style="zoom: 67%;" />



### 2.11 异常处理

```java
public class Demo3_11_1 {
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        }
    }
}
```



```java
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
        stack=1, locals=3, args_size=1
            0: iconst_0
            1: istore_1
            2: bipush 10
            4: istore_1
            5: goto 12
            8: astore_2
            9: bipush 20
            11: istore_1
            12: return
        Exception table:
            from 	to 	target type
                2 	5 	8 		Class java/lang/Exception
        LineNumberTable: ...
        LocalVariableTable:
            Start 	Length 	Slot	 Name 	Signature
                9 	3	 	2 			e 		Ljava/lang/Exception;
                0 	13 		0 			args 	[Ljava/lang/String;
                2 	11 		1 			i 		I
        StackMapTable: ...
      MethodParameters: ...
}

```

- 可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开的检测范围，一旦这个范围 内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号
- 8 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置



### 2.12 finally原理

* finally的原理是将finally{}块中的代码分别放在try{...}的最后和catch{...}的最后

* 如果try出了问题,直接进入catch中,然后catch后面复制的finally就会被执行

* 如果没有出问题,try{}后面的代码就会被执行

* 可以看到 finally 中的代码被复制了 3 份，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流 程

### 2.13 finally面试题

```java
public class Demo3_11_4 {
    public static void main(String[] args) {
        int i = 0;
        try {
            i = 10;
        } catch (Exception e) {
            i = 20;
        } finally {
            i = 30;
        }
    }
}
```

字节码：

```java
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=4, args_size=1
         0: iconst_0
         1: istore_1
         2: bipush        10
         4: istore_1
         5: bipush        30
         7: istore_1
         8: goto          27
        11: astore_2
        12: bipush        20
        14: istore_1
        15: bipush        30
        17: istore_1
        18: goto          27
        21: astore_3
        22: bipush        30
        24: istore_1
        25: aload_3
        26: athrow
        27: return
      Exception table:
         from    to  target type
             2     5    11   Class java/lang/Exception
             2     5    21   any
            11    15    21   any
      LineNumberTable:
        line 10: 0
        line 12: 2
        line 16: 5
        line 17: 8
        line 13: 11
        line 14: 12
        line 16: 15
        line 17: 18
        line 16: 21
        line 17: 25
        line 18: 27
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
           12       3     2     e   Ljava/lang/Exception;
            0      28     0  args   [Ljava/lang/String;
            2      26     1     i   I
      StackMapTable: number_of_entries = 3
        frame_type = 255 /* full_frame */
          offset_delta = 11
          locals = [ class "[Ljava/lang/String;", int ]
          stack = [ class java/lang/Exception ]
        frame_type = 73 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
        frame_type = 5 /* same */
}

```



#### finally中出现了return

```java
public class Demo3_12_2 {
    public static void main(String[] args) {
        int result = test();
        System.out.println(result);
    }
    public static int test() {
        try {
            return 10;
        } finally {
            return 20;
        }
    }
}

```

字节码：

```java
 public static int test();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=2, args_size=0
         0: bipush        10  // <- 10 放入栈顶
         2: istore_0		  // 10 -> slot 0 (从栈顶移除)
         3: bipush        20  // <- 20 放入栈顶
         5: ireturn			  // 返回栈顶 int(20)
         6: astore_1	 	  // catch any -> slot 1
         7: bipush        20  // <- 20 放入栈顶
         9: ireturn			  // 返回栈顶 int(20)
      Exception table:
         from    to  target type
             0     3     6   any
      LineNumberTable:
        line 15: 0
        line 17: 3
      StackMapTable: number_of_entries = 1
        frame_type = 70 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
}

```

- 由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以 finally 的为准
- 至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子
- 跟上例中的 finally 相比，发现没有 athrow 了，这告诉我们：如果在 finally 中出现了 return，会 吞掉异常😱😱😱，可以试一下下面的代码

#### finally吞掉异常

```java
public class Demo3_12_1 {
    public static void main(String[] args) {
        int result = test();
        System.out.println(result);
    }
    public static int test() {
        try {
            int i = 1/0;
            return 10;
        } finally {
            return 20;
        }
    }
}
```

结果是输出20，异常被吞掉了，我们看下字节码

```java
public static int test();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=0
         0: iconst_1
         1: iconst_0
         2: idiv
         3: istore_0
         4: bipush        10
         6: istore_1
         7: bipush        20
         9: ireturn
        10: astore_2
        11: bipush        20
        13: ireturn
      Exception table:
         from    to  target type
             0     7    10   any
      LineNumberTable:
        line 15: 0
        line 16: 4
        line 18: 7
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            4       6     0     i   I
      StackMapTable: number_of_entries = 1
        frame_type = 74 /* same_locals_1_stack_item */
          stack = [ class java/lang/Throwable ]
}

```

#### finally对返回值的影响

```java
public class Demo3_12_2 {
    public static void main(String[] args) {
        int result = test();
        System.out.println(result);
    }
    public static int test() {
        int i = 10;
        try {
            return i;
        } finally {
            i = 20;
        }
    }
}
```

字节码：

```java
public static int test();
    descriptor: ()I
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=1, locals=3, args_size=0
         0: bipush        10	// <- 放入栈顶
         2: istore_0			// 10 -> i
         3: iload_0				// <- i(10)
         4: istore_1			// 10 -> slot 1,暂存至 slot 1，目的是为了固定返回值
         5: bipush        20	// <- 20 放入栈顶
         7: istore_0			// 20 -> i
         8: iload_1				// <- slot 1(10) 载入 slot 1 暂存的值
         9: ireturn				// 返回栈顶的 int(10)
        10: astore_2
        11: bipush        20
        13: istore_0
        14: aload_2
        15: athrow
      Exception table:
         from    to  target type
             3     5    10   any
      LineNumberTable:
        line 14: 0
        line 16: 3
        line 18: 5
        line 16: 8
        line 18: 10
        line 19: 14
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            3      13     0     i   I
      StackMapTable: number_of_entries = 1
        frame_type = 255 /* full_frame */
          offset_delta = 10
          locals = [ int ]
          stack = [ class java/lang/Throwable ]
}

```

### 2.13 synchronized底层原理

```java
public class TestSynchronized {
    public static void main(String[] args) {
        Object lock = new Object();
        synchronized (lock){
            System.out.println("ok");
        }
    }
}
```

字节码：

```java
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: new           #2                  // class java/lang/Object
         3: dup				//将对象的应用地址复制了一份放入操作数栈
         4: invokespecial #1                  // Method java/lang/Object."<ini
t>":()V
         7: astore_1		// lock引用 -> lock
         8: aload_1			// <- lock （synchronized开始）
         9: dup				// 复制lock的引用
        10: astore_2		// lock引用 -> slot 2
        11: monitorenter    // monitorenter(lock引用)
        12: getstatic     #3                  // Field java/lang/System.out:Lj
ava/io/PrintStream;
        15: ldc           #4                  // String ok
        17: invokevirtual #5                  // Method java/io/PrintStream.pr
intln:(Ljava/lang/String;)V
        20: aload_2
        21: monitorexit		// monitorexit(lock引用)
        22: goto          30
        25: astore_3		// any -> slot 3
        26: aload_2			// <- slot 2(lock引用)
        27: monitorexit		// monitorexit(lock引用)
        28: aload_3
        29: athrow
        30: return
      Exception table:
         from    to  target type
            12    22    25   any
            25    28    25   any
      LineNumberTable:
        line 10: 0
        line 11: 8
        line 12: 12
        line 13: 20
        line 14: 30
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      31     0  args   [Ljava/lang/String;
            8      23     1  lock   Ljava/lang/Object;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 25
          locals = [ class "[Ljava/lang/String;", class java/lang/Object, clas
s java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4
}
```

>注意：
>
>方法级别的 synchronized 不会在字节码指令中有所体现

## 3. 编译器处理

所谓的 语法糖 ，其实就是指 java 编译器把 `*.java` 源码编译为 `*.class` 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃嘛） 

注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了` 几乎等价` 的 java 源码方式，并 不是编译器还会转换出中间的 java 源码，切记。

### 3.1 默认构造器

```java
public class Candy1 {
}

```

编译成字节码后的伪代码：

```java
public class Candy1 {
    // 这个无参构造是编译器帮助我们加上的
    public Candy1() {
        super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object."<init>":()V
    }
}
```

### 3.2 自动拆装箱

这个特性是 JDK 5 开始加入的， 代码片段1 ：

```java
public class Candy2 {
    public static void main(String[] args) {
        Integer x = 1;
        int y = x;
    }
}
```

这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 :

```java
public class Candy2 {
    public static void main(String[] args) {
        Integer x = Integer.valueOf(1);
        int y = x.intValue();
    }
}
```

显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间来回转换（尤其是集合类中操作的都是 包装类型），因此这些转换的事情在 JDK 5 以后都由编译器在编译阶段完成。即 `代码片段1` 都会在编 译阶段被转换为 `代码片段2`

### 3.3 泛型集合取值

泛型也是在 `JDK 5` 开始加入的特性，但 java 在编译泛型代码后会执行 `泛型擦除` 的动作，即泛型信息 在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：

```java
public class Candy3 {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(10); // 实际调用的是 List.add(Object e)
        Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index);
    }
}
```

所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：

```java
// 需要将 Object 转为 Integer
Integer x = (Integer)list.get(0);
```

如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：

```java
// 需要将 Object 转为 Integer, 并执行拆箱操作
int x = ((Integer)list.get(0)).intValue();
```

还好这些麻烦事都不用自己做。

擦除的是字节码上的泛型信息，可以看到 `LocalVariableTypeTable` 仍然保留了方法参数泛型的信息

```java
 public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class java/util/ArrayList
         3: dup
         4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
         7: astore_1
         8: aload_1
         9: bipush        10
        11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
        19: pop
        20: aload_1
        21: iconst_0
        22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
        27: checkcast     #7                  // class java/lang/Integer
        30: astore_2
        31: return
      LineNumberTable:
        line 13: 0
        line 14: 8
        line 15: 20
        line 16: 31
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      32     0  args   [Ljava/lang/String;
            8      24     1  list   Ljava/util/List;
           31       1     2     x   Ljava/lang/Integer;
      LocalVariableTypeTable:
        Start  Length  Slot  Name   Signature
            8      24     1  list   Ljava/util/List<Ljava/lang/Integer;>;
}

```

使用反射，仍然能够获得这些信息：

```java
public Set<Integer> test(List<String> list, Map<Integer, Object> map) {
}
```

```java
Method test = Candy3.class.getMethod("test", List.class, Map.class);
Type[] types = test.getGenericParameterTypes();
for (Type type : types) {
    if (type instanceof ParameterizedType) {
        ParameterizedType parameterizedType = (ParameterizedType) type;
        System.out.println("原始类型 - " + parameterizedType.getRawType());
        Type[] arguments = parameterizedType.getActualTypeArguments();
        for (int i = 0; i < arguments.length; i++) {
            System.out.printf("泛型参数[%d] - %s\n", i, arguments[i]);
        }
    }
}

```

输出：

```java
原始类型 - interface java.util.List
泛型参数[0] - class java.lang.String
原始类型 - interface java.util.Map
泛型参数[0] - class java.lang.Integer
泛型参数[1] - class java.lang.Object
```

### 3.4 可变参数

可变参数也是 JDK 5 开始加入的新特性：

例如：

```java
public class Candy4 {
    public static void foo(String... args) {
        String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
        foo("hello", "world");
    }
}
```

可变参数 `String... args `其实是一个 `String[] args `，从代码中的赋值语句中就可以看出来。 同样 `java `编译器会在编译期间将 上述代码变换为：

```java
public class Candy4 {
    public static void foo(String[] args) {
        String[] array = args; // 直接赋值
        System.out.println(array);
    }
    public static void main(String[] args) {
        foo(new String[]{"hello", "world"});
    }
}

```

>注意 如果调用了 `foo()` 则等价代码为 `foo(new String[]{})` ，创建了一个空的数组，而不会传递 `null `进去

### 3.5 foreach 循环

仍是 `JDK 5` 开始引入的语法糖，数组的循环：

```java
public class Candy5_1 {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5}; // 数组赋初值的简化写法也是语法糖哦
        for (int e : array) {
            System.out.println(e);
        }
    }
}
```

会被编译器转换为：

```java
public class Candy5_1 {
    public Candy5_1() {
    }
    public static void main(String[] args) {
        int[] array = new int[]{1, 2, 3, 4, 5};
        for(int i = 0; i < array.length; ++i) {
            int e = array[i];
            System.out.println(e);
        }
    }
}
```

而集合的循环：

```java
public class Candy5_2 {
    public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1,2,3,4,5);
        for (Integer i : list) {
            System.out.println(i);
        }
    }
}
```

实际被编译器转换为对迭代器的调用：

```java
public class Candy5_2 {
    public Candy5_2() {
    }
    public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
    Iterator iter = list.iterator();
        while(iter.hasNext()) {
            Integer e = (Integer)iter.next();
            System.out.println(e);
        }
    }
}
```

>注意 
>
>foreach 循环写法，能够配合数组，以及所有实现了 `Iterable `接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器（ `Iterator `）

### 3.6 switch 字符串

从 `JDK 7` 开始，switch 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：

```java
public class Candy6_1 {
    public static void choose(String str) {
        switch (str) {
            case "hello": {
                System.out.println("h");
                break;
            }
            case "world": {
                System.out.println("w");
                break;
            }
        }
    }
}
```

>注意 
>
>switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自然清 楚

会被编译器转换为：

```java
public class Candy6_1 {
    public Candy6_1() {
    }
    public static void choose(String str) {
        byte x = -1;
        switch(str.hashCode()) {
            case 99162322: // hello 的 hashCode
                if (str.equals("hello")) {
                    x = 0;
                }
                break;
            case 113318802: // world 的 hashCode
                if (str.equals("world")) {
                    x = 1;
                }
        }
        switch(x) {
            case 0:
                System.out.println("h");
                break;
            case 1:
                System.out.println("w");
        }
    }
}
```

可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。 

为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可 能的比较；而 equals 是为了防止 hashCode 冲突，例如 BM 和 C. 这两个字符串的hashCode值都是 2123 ，如果有如下代码：

```java
public class Candy6_2 {
    public static void choose(String str) {
        switch (str) {
            case "BM": {
                System.out.println("h");
                break;
            }
            case "C.": {
                System.out.println("w");
                break;
            }
        }
    }
}
```

会被编译器转换为：

```java
public class Candy6_2 {
    public Candy6_2() {
    }
    public static void choose(String str) {
        byte x = -1;
        switch(str.hashCode()) {
            case 2123: // hashCode 值可能相同，需要进一步用 equals 比较
                if (str.equals("C.")) {
                    x = 1;
                } else if (str.equals("BM")) {
                    x = 0;
                }
            default:
                switch(x) {
                    case 0:
                        System.out.println("h");
                        break;
                    case 1:
                        System.out.println("w");
                }
        }
    }
}
```

### 3.7 switch 枚举

switch 枚举的例子，原始代码：

```java
enum Sex {
    MALE, FEMALE
}
```

```java
public class Candy7 {
    public static void foo(Sex sex) {
        switch (sex) {
            case MALE:
                System.out.println("男"); break;
            case FEMALE:
                System.out.println("女"); break;
        }
    }
}
```

转换后代码：

>枚举类其实底层会生成一个静态内部类，我们称之为合成类

```java
public class Candy7 {
    /**
     * 定义一个合成类（仅 jvm 使用，对我们不可见）
     * 用来映射枚举的 ordinal 与数组元素的关系
     * 枚举的 ordinal 表示枚举对象的序号，从 0 开始
     * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1
     */
    static class $MAP {
        // 数组大小即为枚举元素个数，里面存储case用来对比的数字
        static int[] map = new int[2];
        static {
            map[Sex.MALE.ordinal()] = 1;
            map[Sex.FEMALE.ordinal()] = 2;
        }
    }
    public static void foo(Sex sex) {
        int x = $MAP.map[sex.ordinal()];// sex.ordinal()枚举的编号
        switch (x) {
            case 1:
                System.out.println("男");
                break;
            case 2:
                System.out.println("女");
                break;
        }
    }
}
```

### 3.8 枚举类

JDK 7 新增了枚举类，以前面的性别枚举为例：

```java
enum Sex {
    MALE, FEMALE
}
```

转换后代码：

```java
public final class Sex extends Enum<Sex> {
    public static final Sex MALE;
    public static final Sex FEMALE;
    private static final Sex[] $VALUES;
    static {
        MALE = new Sex("MALE", 0);
        FEMALE = new Sex("FEMALE", 1);
        $VALUES = new Sex[]{MALE, FEMALE};
    }
    /**
     * Sole constructor. Programmers cannot invoke this constructor.
     * It is for use by code emitted by the compiler in response to
     * enum type declarations.
     *
     * @param name - The name of this enum constant, which is the identifier
     * used to declare it.
     * @param ordinal - The ordinal of this enumeration constant (its position
     * in the enum declaration, where the initial constant is assigned
     */
    private Sex(String name, int ordinal) {
        super(name, ordinal);
    }
    public static Sex[] values() {
        return $VALUES.clone();
    }
    public static Sex valueOf(String name) {
        return Enum.valueOf(Sex.class, name);
    }
}

```

### 3.9 try-with-resources

JDK 7 开始新增了对需要关闭的资源处理的特殊语法 `try-with-resources`：

```java
try(资源变量 = 创建资源对象){
    
} catch( ) {
    
}
```

其中资源对象需要实现 **AutoCloseable** 接口，例如 **InputStream** 、 **OutputStream** 、 **Connection** 、 **Statement** 、 **ResultSet** 等接口都实现了 **AutoCloseable** ，使用 `try-with[]resources` 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如

```java
public class Candy9 {
    public static void main(String[] args) {
        try(InputStream is = new FileInputStream("d:\\1.txt")) {
            System.out.println(is);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

会被jvm转换为：

```java
public class Candy9 {
    public Candy9() {
    }
    public static void main(String[] args) {
        try {
            InputStream is = new FileInputStream("d:\\1.txt");
            Throwable t = null;
            try {
                System.out.println(is);
            } catch (Throwable e1) {
                // t 是我们代码出现的异常
                t = e1;
                throw e1;
            } finally {
                // 判断了资源不为空
                if (is != null) {
                    // 如果我们代码有异常
                    if (t != null) {
                        try {
                            is.close();
                        } catch (Throwable e2) {
                            // 如果 close 出现异常，作为被压制异常添加
                            t.addSuppressed(e2);
                        }
                    } else {
                        // 如果我们代码没有异常，close 出现的异常就是最后 catch 块中的 e
                        is.close();
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

为什么要设计一个 **addSuppressed(Throwable e)** （添加被压制异常）的方法呢？是为了防止异常信 息的丢失（想想 try-with-resources 生成的 fianlly 中如果抛出了异常）：

```java
public class Test6 {
    public static void main(String[] args) {
        try (MyResource resource = new MyResource()) {
            int i = 1/0;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
class MyResource implements AutoCloseable {
    public void close() throws Exception {
        throw new Exception("close 异常");
    }
}
```

输出：

```ruby
java.lang.ArithmeticException: / by zero
    at test.Test6.main(Test6.java:7)
    Suppressed: java.lang.Exception: close 异常
        at test.MyResource.close(Test6.java:18)
        at test.Test6.main(Test6.java:6)
```

如以上代码所示，两个异常信息都不会丢。

### 3.10 方法重写时的桥接方法 

我们都知道，方法重写时对返回值分两种情况

- 父子类的返回值完全一致 
- 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子）

### 3.11 匿名内部类

源代码：

```java
public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("ok");
            }
        };
    }
}
```

转换后代码：

```java
final class Candy11$1 implements Runnable {
    Candy11$1() {
    }
    public void run() {
        System.out.println("ok");
    }
}
```

```java
public class Candy11 {
    public static void main(String[] args) {
        Runnable runnable = new Candy11$1();
    }
}
```

引用局部变量的匿名内部类，源代码：

```java
public class Candy11 {
    public static void test(final int x) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("ok:" + x);
            }
        };
    }
}
```

转换后代码：

```java
// 额外生成的类
final class Candy11$1 implements Runnable {
    int val$x;
    Candy11$1(int x) {
        this.val$x = x;
    }
    public void run() {
        System.out.println("ok:" + this.val$x);
    }
}
```

```java
public class Candy11 {
    public static void test(final int x) { //java8中可以不用写final 语法糖
        Runnable runnable = new Candy11$1(x);
    }
}
```

>注意 
>
>这同时解释了为什么匿名内部类引用局部变量时，局部变量必须是 `final `的：因为在创建 Candy11$1 对象时，将 x 的值赋值给了 Candy11$1 对象的 val$x 属性，所以 x 不应该再发生变 化了，如果变化，那么 val$x 属性没有机会再跟着一起变化

