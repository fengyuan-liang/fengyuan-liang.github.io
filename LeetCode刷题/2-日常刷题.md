# 日常刷题



## 回文串相关

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

```go
func longestPalindrome(s string) string {
	var (
		array  = []rune(s)
		maxStr = ""
	)

	for i := 0; i < len(array); i++ {
		// 寻找奇数长度的回文子串
		oddStr := expandAroundCenter(array, i, i)
		if len(oddStr) > len(maxStr) {
			maxStr = oddStr
		}

		// 寻找偶数长度的回文子串
		evenStr := expandAroundCenter(array, i, i+1)
		if len(evenStr) > len(maxStr) {
			maxStr = evenStr
		}
	}

	return maxStr
}

func expandAroundCenter(s []rune, left, right int) string {
	for left >= 0 && right < len(s) && s[left] == s[right] {
		left--
		right++
	}
	return string(s[left+1 : right])
}
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> map = new HashMap<>();
        int maxLen = 0;//用于记录最大不重复子串的长度
        int left = 0;//滑动窗口左指针
        for (int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))) {
                left = Math.max(left, map.get(s.charAt(i)) + 1);
            }
            //不管是否更新left，都要更新 s.charAt(i) 的位置！
            map.put(s.charAt(i), i);
            maxLen = Math.max(maxLen, i - left + 1);
        }

        return maxLen;
    }
}
```

## 链表相关

```go
type ListNode struct {
	Val  int
	Next *ListNode
}
```

### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	prev := new(ListNode)
	currentNode := prev
	for list1 != nil && list2 != nil {
		if list1.Val < list2.Val {
			currentNode.Next = list1
			list1 = list1.Next
		} else {
			currentNode.Next = list2
			list2 = list2.Next
		}
		currentNode = currentNode.Next
	}
	// 将剩余的接上
	if list1 != nil {
		currentNode.Next = list1
	}
	if list2 != nil {
		currentNode.Next = list2
	}
	return prev.Next
}
```

### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
		return nil
	}
    if len(lists) == 1 {
		return lists[0]
	}
	for i := 0; i + 1 < len(lists); i++ {
		lists[i+1] = mergeTwoLists(lists[i], lists[i+1])
	}
	return lists[len(lists) - 1]
}

func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	prev := new(ListNode)
	currentNode := prev
	for list1 != nil && list2 != nil {
		if list1.Val < list2.Val {
			currentNode.Next = list1
			list1 = list1.Next
		} else {
			currentNode.Next = list2
			list2 = list2.Next
		}
		currentNode = currentNode.Next
	}
	// 将剩余的接上
	if list1 != nil {
		currentNode.Next = list1
	}
	if list2 != nil {
		currentNode.Next = list2
	}
	return prev.Next
}
```

**二分法优化**

```go
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    return mergeHelper(lists, 0, len(lists)-1)
}

func mergeHelper(lists []*ListNode, start, end int) *ListNode {
    if start == end {
        return lists[start]
    }
    if start < end {
        mid := (start + end) / 2
        left := mergeHelper(lists, start, mid)
        right := mergeHelper(lists, mid+1, end)
        return mergeTwoLists(left, right)
    }
    return nil
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

快慢指针，快指针先领先n个位置，然后一起往后，当快指针为nil时，慢指针指向的位置就是需要删除的节点

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
        dummy := &ListNode{0, head}
        slow, fast := dummy, dummy

        // 移动 fast 指针 N 步
        for i := 0; i <= n; i++ {
            fast = fast.Next
        }

        // 同时移动 slow 和 fast 指针
        for fast != nil {
            slow = slow.Next
            fast = fast.Next
        }

        // 删除倒数第 N 个节点
        slow.Next = slow.Next.Next

        return dummy.Next
}
```



## 动态规划

### 背包问题

![image-20231226001226570](https://cdn.fengxianhub.top/resources-master/image-20231226001226570.png)

常见的`0-1背包`

```python
# capacity 背包的容量
# w[i]:第 i 个物品的体积
# v[i]: 第 i 个物品的价值
# 返回所选物品体积和不超过capacity的前提下所能得到的最大价值和
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)

    def dfs(i, c):
        if i < 0:
            return 0
        if c < w[i]:
            return dfs(i - 1, c)
        return max(dfs(i - 1, c), dfs(i - 1, c - w[i]) + v[i])
    
    return dfs(n - 1, capacity)
```

#### [494. 目标和](https://leetcode.cn/problems/target-sum/)

这题是01背包的变形

![image-20231226003340409](https://cdn.fengxianhub.top/resources-master/image-20231226003340409.png)

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
    # p = 添加正数的数的和
    # s - p = 添加负数的数（s为总数）
    # p - (s - p) = t (target 结果) => 2p - s = t
    # p = (t + s) / 2



# capacity 背包的容量
# w[i]:第 i 个物品的体积
# v[i]: 第 i 个物品的价值
# 返回所选物品体积和不超过capacity的前提下所能得到的最大价值和
def zero_one_knapsack(capacity: int, w: List[int], v: List[int]) -> int:
    n = len(w)

    def dfs(i, c):
        if i < 0:
            return 0
        if c < w[i]:
            return dfs(i - 1, c)
        return max(dfs(i - 1, c), dfs(i - 1, c - w[i]) + v[i])
    
    return dfs(n - 1, capacity)
```







### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

```go

```

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

这题我们可以先看成简单的回溯题，但是回溯时间复杂度是指数级别，比较高，我们可以缓存一下搜索到的结果

![image-20231225225705498](https://cdn.fengxianhub.top/resources-master/image-20231225225705498.png)

优化后我们可以看到现在这颗BST只有n个节点了，所以时间复杂度是`O(n)`

![image-20231225225825869](https://cdn.fengxianhub.top/resources-master/image-20231225225825869.png)

python代码如下

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        @cache
        def dfs(i):
            if i < 0:
                return 0
            return max(dfs(i - 1), dfs(i - 2) + nums[i])
        # 回溯时间复杂度是指数级别
        return dfs(n - 1)
```

当然我们可以不用cache的装饰器，我们可以自己记录之前搜索过的值

```go
func rob(nums []int) int {
    // 缓存子问题的值
    var (
        n = len(nums)
        cache = func() []int {
            memo := make([]int, n)
            for i := range memo {
                memo[i] = -1 // -1 表示没有计算过
            }
            return memo
        }()
    )
	var dfs func(int) int
	dfs = func(index int) (res int) {
		if index < 0 {
			return
		}
        // 如果已经有子问题的解了 就不往下找了
        if cache[index] != -1 {
            return cache[index]
        }
		// 把问题拆分为最后一个元素 选与不选两种清空
		res = max(dfs(index-1), dfs(index-2)+nums[index])
        // 缓存结果
        cache[index] = res
        return res
	}
	return dfs(len(nums) - 1)
}

func max(i, j int) int {
	if i > j {
		return i
	}
	return j
}
```

还能不能再优化下呢，我们仔细观察就能发现

![image-20231225231830854](https://cdn.fengxianhub.top/resources-master/image-20231225231830854.png)

我们可以将dfs改为数组，然后将递归改为循环，注意上面可能产生负数下标，所以进行`+2`

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        f = [0] * (n + 2)
        for i, x in enumerate(nums):
            f[i + 2] = max(f[i + 1], f[i] + x)
        return f[n + 1]
```

此时空间复杂度为`O(n)`，那么如何降到`O(1)`呢

![image-20231225234930423](https://cdn.fengxianhub.top/resources-master/image-20231225234930423.png)

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        f0 = f1 = 0
        for i, x in enumerate(nums):
            new_f = max(f1, f0 + x)
            f0 = f1
            f1 = new_f
            # f0, f1 = f1, max(f1, f0 + x)
        return f1
```

```go
func rob(nums []int) int {
    var f0, f1 int
    for _, value := range nums {
        f0, f1 = f1, max(f1, f0 + value)
    }
    println(f0)
    return f1
}

func max(i, j int) int {
	if i > j {
		return i
	}
	return j
}
```



## 回溯

### [77. 组合](https://leetcode.cn/problems/combinations/)

```go
```



## 贪心

### [135. 分发糖果](https://leetcode.cn/problems/candy/)

```go
func candy(ratings []int) int {
	var (
		n       = len(ratings)
		candies = make([]int, n)
	)
	candies[0] = 1
	// 从左到右贪心
	for i := 1; i < n; i++ {
		if ratings[i] > ratings[i-1] {
			candies[i] = candies[i-1] + 1
		} else {
			candies[i] = 1
		}
	}
	// 从右往左贪心
	for i := n - 2; i >= 0; i-- {
		if ratings[i] > ratings[i+1] && candies[i] <= candies[i+1] {
			candies[i] = candies[i+1] + 1
		}
	}
	var sum = 0
	for _, value := range candies {
		sum += value
	}
	return sum
}
```

>贪心算法（Greedy Algorithm）是一种基于贪心策略的算法思想。贪心策略的核心思想是，在每一步选择中都选择当前状态下的最优解，以期望最终获得全局最优解。
>
>在解决问题时，贪心算法每次选择局部最优解，不考虑该选择对未来的影响，并且认为通过一系列局部最优解的选择，可以达到全局最优解。贪心算法通常适用于满足"最优子结构"和"贪心选择性质"的问题。
>
>"最优子结构"指的是问题的最优解包含了子问题的最优解。也就是说，通过解决子问题的最优解，可以得到原问题的最优解。
>
>"贪心选择性质"指的是贪心算法通过局部最优解的选择，期望最终得到全局最优解。这意味着在每一步的选择中，贪心算法选择当前最优的解决方案，而不考虑其他选择所带来的影响。
>
>在解决问题时，贪心算法不保证能够得到全局最优解，因为它没有考虑所有可能的解决方案。但在一些问题中，贪心算法能够给出近似最优解或者满足问题要求的解。
>
>在分发糖果的问题中，贪心算法的思路是先从左到右遍历一次评分数组，保证相邻两个孩子评分更高的孩子获得更多的糖果；然后再从右到左遍历一次评分数组，确保相邻两个孩子评分更高的孩子获得更多的糖果。通过贪心策略，每次都选择当前最优解，最终得到满足要求的最少糖果数目。

## 背包问题

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```go
func coinChange(coins []int, amount int) int {
    // 初始化 dp 数组
    dp := make([]int, amount+1)
    for i := 1; i <= amount; i++ {
        dp[i] = math.MaxInt32
    }

    // 动态规划计算最少硬币个数
    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if i-coin >= 0 && dp[i-coin] != math.MaxInt32 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }

    if dp[amount] == math.MaxInt32 {
        return -1
    }

    return dp[amount]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## 图算法

### Floyd算法

#### [100156. 转换字符串的最小成本 I](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/)

```go

```

#### [1334. 阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)



## 其他

### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

java版本的比较简单，就是`LinkedHashMap`中使用hashMap维护节点快速插入寻找，使用双向链表维护顺序

>简单介绍LinkedHashMap（跟题目有关的知识点）
>HashMap 大家都清楚，底层是 数组 + 红黑树 + 链表 （不清楚也没有关系），同时其是无序的，而 LinkedHashMap 刚好就比 HashMap 多这一个功能，就是其提供 有序，并且，LinkedHashMap的有序可以按两种顺序排列，一种是按照插入的顺序，一种是按照 读取 的顺序（这个题目的示例就是告诉我们要按照读取的顺序进行排序），而其内部是靠 建立一个双向链表 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准确的来说，是有三个函数来做这件事，这三个函数都统称为 回调函数 ，这三个函数分别是：
>
>void afterNodeAccess(Node<K,V> p) { }
>其作用就是在访问元素之后，将该元素放到双向链表的尾巴处(所以这个函数只有在按照读取的顺序的时候才会执行)，之所以提这个，是建议大家去看看，如何优美的实现在双向链表中将指定元素放入链尾！
>void afterNodeRemoval(Node<K,V> p) { }
>其作用就是在删除元素之后，将元素从双向链表中删除，还是非常建议大家去看看这个函数的，很优美的方式在双向链表中删除节点！
>void afterNodeInsertion(boolean evict) { }
>这个才是我们题目中会用到的，在插入新元素之后，需要回调函数判断是否需要移除一直不用的某些元素！
>其次，我再介绍一下 LinkedHashMap 的构造函数！
>其主要是两个构造方法，一个是继承 HashMap ，一个是可以选择 accessOrder 的值(默认 false，代表按照插入顺序排序)来确定是按插入顺序还是读取顺序排序

```java
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    // 这个可不写
    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}
```



golang

```go
type LRUCache struct {
    capacity int
    cache    map[int]*Node
    head     *Node
    tail     *Node
}

type Node struct {
    key   int
    value int
    prev  *Node
    next  *Node
}

func Constructor(capacity int) LRUCache {
    head := &Node{}
    tail := &Node{}
    head.next = tail
    tail.prev = head

    return LRUCache{
        capacity: capacity,
        cache:    make(map[int]*Node),
        head:     head,
        tail:     tail,
    }
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
    } else {
        newNode := &Node{
            key:   key,
            value: value,
        }
        this.cache[key] = newNode
        this.addToHead(newNode)
        if len(this.cache) > this.capacity {
            removedNode := this.removeTail()
            delete(this.cache, removedNode.key)
        }
    }
}

func (this *LRUCache) addToHead(node *Node) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *Node) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *Node) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *Node {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
```

