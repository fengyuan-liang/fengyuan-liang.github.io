# 回溯算法

### [77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```java
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

```java
输入：n = 1, k = 1
输出：[[1]]
```

如例一，如果k固定为2的话其实我们很快可以通过双重循环解决

```java
List<List<Integer>> result = new ArrayList<>();
for(int i = 1; i <= 4; ++i){
    List<Integer> list = new ArrayList<>();
    for(int j = i + 1; j < 4; ++j){
        // 因为k为2，所以只能装两个元素，超过了2个清空集合
        if(list.size == 2){
            list.clear();
        }else {
            list.add(i);
            list.add(j);
            result.add(list)
        }
    }
}
```

如果是 n = 4, k = 3，那就套三层

```java
for (int i = 0; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int q = j + 1; q <= n ; q++) {
            // 添加逻辑
        }
    }
}
```

但是这样显然 k 我们是不确定的，所以要套几层循环我们也是不知道的

我们仔细观看就会发现，一层一层往下套，这不就是递归的特点吗？我们是不是可以写一个递归函数，通过递归达到产生k层for循环的目的呢？当然可以

```java
List<List<Integer>> result = new ArrayList<>();
List<Integer> path = new ArrayList<>();
void backtracking(int n, int k, int startIndex){
    // 递归要有递归出口
    if(path.size() == k){
        result.add(path);
        return;
    }
    for (int i = startIndex; i <= n; i++) {
        // 添加逻辑
        path.add(i);
        // 递归调用，并且传递下一层递归的起始的元素
        backtracking(n, k, i + 1);
        // 回溯，将集合清空
        path.clear();
    }
}
```

然后你就会发现输出结果为

```java
[[], [], [], []]
```

- 首先，Java里面函数传参时只有值传递，所以`path.clear()`会将result保存的数据清空，我们要重新new一个集合保存
- 其次，为什么只输出了四个呢？我们想的是要输出六个，那是因为我们每一次清空就直接将整个数组清空了，我们应该在`path`中保留前面的结果，每一次只清空最后一个元素

我们跟换之后为

```java
List<List<Integer>> result = new ArrayList<>();
LinkedList<Integer> path = new LinkedList<>();
void backtracking(int n, int k, int startIndex) {
    // 递归要有递归出口
    if (path.size() == k) {
        result.add(new ArrayList<>(path));
        return;
    }
    for (int i = startIndex; i <= n; i++) {
        // 添加逻辑
        path.add(i);
        // 递归调用，并且传递下一层递归的起始的元素
        backtracking(n, k, i + 1);
        // 回溯，将集合清空
        path.removeLast();
    }
}
```



![image-20221007231034055](https://cdn.fengxianhub.top/resources-master/202210072310145.png)

#### 减枝优化

我们知道递归本身就会产生重复的计算，在上面的代码中，如果`n = 4，k = 4`的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了

![image-20221007231720279](https://cdn.fengxianhub.top/resources-master/202210072317364.png)

 所以我们还需要进行减枝优化，即在第一层时会发现，第二次循环已经没有意义了，在第二层同理第二次循环也没有意义了，所以我们减枝优化一下

我们会发现，如果`n = 4，k = 4`，当第一层中取到2时，已经凑不出k个元素了，所以此时应该停止循环，那么如果判断呢？我们需要看我们的LinkedList中现在有多少元素，推理过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

**举个例子，n = 4，k = 3， 目前没有选取元素（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2，所以至少要小于等于2，大于2的就可以不用循环了**

```java
```

