# 阻塞线程模型&异步编程

- 部分参考来自 [vertx官网](https://vertx-china.github.io/introduction-to-vertx-and-reactive/)

实现并发的经典方法是使用 **线程**。 多个线程可以在同一个 **进程** 中存活，**并行** 地执行工作，并 **共享** 同一片内存空间

![image-20230323003109221](https://cdn.fengxianhub.top/resources-master/202303230031493.png)

## 1. 多线程带来的问题

### 1.1 C10k问题

C10k 问题是`优化网络套接字`以同时处理大量客户端的问题。之所以称之为 `C10k` ，是因为它需要面对的是如何并发处理`一万个`个连接

处理`许多并发连接`与每秒处理许多请求（requests per second，QPS）是两个不同的问题：

- 后者需要高吞吐量（快速处理）
- 前者不需要快速，但需要有效的连接调度

这个问题是1999年由软件工程师丹 · 凯格尔（Dan Kegel）提出的，到了2010年，出现了`C10M`问题，即1000万个并发连接的问题

- WhatsApp 2010年初在24核心的FreebSD机器上使用`Erlang`处理了`超过200万个连接`

- [MigratoryData ](https://migratorydata.com/blog/migratorydata-with-12-million-concurrent-websockets/)2013年在12个核心的Linux机器上使用`java`处理了`1000万到1200万个连接`


### 1.2 上下文切换问题

在多线程/多进程操作系统中，采用`时间片轮训算法`进行并发，宏观上来说，就算只有一个CPU，也能`并发执行`多个进程

![image-20230223232404660](https://cdn.fengxianhub.top/resources-master/202302232324794.png)

这样的好处是充分利用了CPU，但是也带来了一些问题

- 时间片切换需要花费额外的开销
- 进程/线程的数量越多，切换`成本就越大`，也就越`浪费`

![image-20230223232626050](https://cdn.fengxianhub.top/resources-master/202302232326185.png)

对于开发人员来说，尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如`锁`、`竞争冲突`等

进程拥有太多的资源，进程的`创建、切换、销毁`，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行`进程调度`了

![image-20230223233029634](https://cdn.fengxianhub.top/resources-master/202302232330760.png)

>那么到底什么是`上下文切换`呢？

我们知道操作系统的一些核心接口是不能被进程随意调度的，例如进行`io流的读写操作`，需要将最终的执行权交给操作系统（内核态）进行调度，所以就会有`用户态和内核态`之前的切换

![](https://cdn.fengxianhub.top/resources-master/202206072259157.png)

这个时候我们的线程模型是这样的

<img src="https://cdn.fengxianhub.top/resources-master/202302232339134.png" alt="image-20230223233902015" style="zoom: 33%;" />

在golang中使用`协程`来解决多线程上下文切换的问题，而vertx使用的就是`异步编程`

### 1.3 阻塞问题

当大量的线程在执行的过程中被阻塞住了会发生什么？

答案很简单：操作系统内核变得 **非常痛苦**，因为多线程处理这些请求会产生太多的 **上下文切换** 动作

![image-20230323010313949](https://cdn.fengxianhub.top/resources-master/202303230103052.png)

一些线程正在等待I/O操作完成而被 **阻塞**，一些线程已 **准备好** 处理I/O结果，而一些线程正在执行CPU密集型操作任务

现代内核具有非常好的调度程序，但是不能指望它们处理`50 000`个线程还会像处理`5 000`个线程那样轻松。同样地，创建线程的成本也不低：创建线程需要花费若干毫秒，而且新线程会消耗大约`1MB`的内存

### 2. 异步编程

异步编程可以提供两大核心特点：

- 可伸缩性
- 资源利用率

当您使用 **异步I/O** 时，可以用`更少的线程`处理`更多的并发连接`。 当一个任务发生了I/O操作时，异步I/O不会阻塞线程，而是执行其他待处理的任务，待到I/O结果准备好后再继续执行该任务

>Vert.x 使用 **事件循环（event­loop）** 多路复用并发处理工作负载

![image-20230323010635835](https://cdn.fengxianhub.top/resources-master/202303230106934.png)